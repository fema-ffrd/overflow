{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overflow","text":"\u2554\u2550\u2557\u2566  \u2566\u2554\u2550\u2557\u2566\u2550\u2557\u2554\u2550\u2557\u2566  \u2554\u2550\u2557\u2566 \u2566 \u2591\u2592\u2593\u2551 \u2551\u255a\u2557\u2554\u255d\u2551\u2563 \u2560\u2566\u255d\u2560\u2563 \u2551  \u2551 \u2551\u2551\u2551\u2551\u2593\u2592\u2591    \u255a\u2550\u255d \u255a\u255d \u255a\u2550\u255d\u2569\u255a\u2550\u255a  \u2569\u2550\u255d\u255a\u2550\u255d\u255a\u2569\u255d    <p>     :: HYDROLOGICAL TERRAIN ANALYSIS   </p>      A high-performance library for processing massive Digital Elevation Models.           &gt; QUICKSTART             INSTALLATION      <p>Alpha Software</p> <p>This software is currently in alpha status. While functional, it may contain bugs, have incomplete features, and undergo breaking changes. Use in production environments at your own risk. We welcome feedback and bug reports on our GitHub Issues page.</p>"},{"location":"#why-overflow","title":"Why Overflow?","text":"<p>Traditional hydrological tools are often single-threaded and rely on virtual-memory tiling (swapping memory to disk) to handle large datasets. This creates inefficient I/O patterns with no garuntees on how many times the same tile may be swapped into and out of memory. Given the wide availability of multi-core processors in modern computers and the increasing size of raster datasets used for hydrological analysis, existing tools are not well-suited for efficient processing of large-scale terrain data today. Overflow was developed to provide a modern solution for large-scale hydrological terrain analysis.</p> <p>Every workflow in Overflow is designed for parallel execution using Numba JIT-compiled algorithms. This is achieved through state-of-the-art tiled, topological approaches that implement efficient IO access patterns even for global operations. Processes in Overflow are guaranteed to complete in a fixed number of passes over the data regardless of the dataset size.</p>"},{"location":"#core-hydrological-processes","title":"Core Hydrological Processes","text":"<p>Overflow provides a complete toolchain for deriving hydrographic features from raw elevation data. The core algorithms implemented in Overflow include:</p> 01 // CONDITIONING <ul> <li> Breach Carve paths through barriers </li> <li> Fill Fill surface depressions </li> </ul> 02 // ROUTING <ul> <li> Flow Direction Determine steepest descent </li> <li> Accumulation Calculate contributing area </li> </ul> 03 // EXTRACTION <ul> <li> Streams Vectorize stream network </li> <li> Basins Delineate watersheds </li> <li> Flow Length Longest Upstream Path </li> </ul>"},{"location":"#python-api","title":"Python API","text":"<p>Overflow is available as a standard Python package making it accessible for integration into geospatial workflows leveraging Python's ecosystem.</p> <pre><code>import overflow\n\noverflow.breach(...)\noverflow.fill(...)\noverflow.flow_direction(...)\noverflow.accumulation(...)\noverflow.streams(...)\noverflow.basins(...)\noverflow.flow_length(...)\n</code></pre>"},{"location":"#command-line-interface-cli","title":"Command Line Interface (CLI)","text":"<p>For batch processing and server environments, Overflow provides a robust CLI. It supports all core algorithms and provides a single command to run the complete processing pipeline end-to-end.</p> <p>Available commands:</p> <ul> <li><code>overflow breach</code> - Breach pits using least-cost paths</li> <li><code>overflow fill</code> - Fill depressions in a DEM</li> <li><code>overflow flow-direction</code> - Compute D8 flow directions (with flat resolution)</li> <li><code>overflow accumulation</code> - Calculate flow accumulation</li> <li><code>overflow streams</code> - Extract stream networks</li> <li><code>overflow basins</code> - Delineate drainage basins</li> <li><code>overflow flow-length</code> - Calculate upstream flow length (longest flow path)</li> <li><code>overflow pipeline</code> - Run complete DEM processing workflow</li> </ul> <p>The <code>pipeline</code> command orchestrates the full sequence of conditioning, flow direction, accumulation, and vector extraction in a single execution.</p> <pre><code>overflow pipeline \\\n    --dem_file raw_dem.tif \\\n    --output_dir ./results\n</code></pre>"},{"location":"#docker-support","title":"Docker Support","text":"<p>To ensure reproducibility and eliminate complex dependency management (specifically GDAL and system libraries), Overflow is distributed with an official Docker image.</p> <p>The image is built on top of the official <code>osgeo/gdal</code> Ubuntu-based images, ensuring binary compatibility with the underlying geospatial libraries.</p>"},{"location":"algorithm-details/","title":"Algorithm Details","text":"<p>This section provides in-depth documentation of the algorithms implemented in Overflow. Each page covers the mathematical foundations, data structures, and implementation details for a specific hydrological processing step.</p>"},{"location":"algorithm-details/#terrain-conditioning","title":"Terrain Conditioning","text":"<p>Prepare raw DEMs for hydrological analysis by removing artificial depressions:</p> <ul> <li>Breach Algorithm - Remove depressions by carving least-cost flow paths</li> <li>Fill Algorithm - Fill depressions using priority-flood</li> </ul>"},{"location":"algorithm-details/#flow-routing","title":"Flow Routing","text":"<p>Determine how water moves across the terrain:</p> <ul> <li>Flow Direction - Compute D8 flow directions</li> <li>Flat Resolution - Resolve undefined flow in flat regions</li> <li>Flow Accumulation - Calculate upstream contributing area</li> </ul>"},{"location":"algorithm-details/#feature-extraction","title":"Feature Extraction","text":"<p>Derive hydrographic features from the flow network:</p> <ul> <li>Stream Extraction - Extract stream networks from flow accumulation</li> <li>Basin Delineation - Delineate drainage basins</li> <li>Flow Length - Calculate upstream flow length and longest flow paths</li> </ul>"},{"location":"algorithm-details/basin-delineation/","title":"Basin Delineation Algorithm","text":""},{"location":"algorithm-details/basin-delineation/#overview","title":"Overview","text":"<p>Basin delineation assigns each cell a label identifying its drainage outlet. The algorithm traces flow paths upstream from outlets, creating watershed boundaries that define the contributing area for each drainage point.</p>"},{"location":"algorithm-details/basin-delineation/#core-concept","title":"Core Concept","text":"<p>The algorithm uses upstream breadth-first search (BFS) from outlet cells. Starting at each outlet, it propagates upstream through the flow direction network, assigning basin labels to all cells that drain to that outlet.</p>"},{"location":"algorithm-details/basin-delineation/#definitions","title":"Definitions","text":"<p>Outlet cell: A cell where flow exits the domain or terminates:</p> \\[ \\text{is\\_outlet}(c) = \\text{downstream}(c) \\text{ is nodata or out of bounds} \\] <p>Drainage point: A user-specified outlet location with an associated basin ID.</p> <p>Upstream neighbor: A cell \\(n\\) is upstream of \\(c\\) if \\(n\\) flows directly to \\(c\\):</p> \\[ \\text{upstream}(n, c) \\iff \\text{downstream}(n) = c \\]"},{"location":"algorithm-details/basin-delineation/#data-structures","title":"Data Structures","text":"Structure Description Labels Array Integer grid storing basin ID for each cell Drainage Points Map from (row, col) to basin ID Basin Graph Directed graph of basin connectivity Queue FIFO queue for BFS traversal"},{"location":"algorithm-details/basin-delineation/#algorithm","title":"Algorithm","text":""},{"location":"algorithm-details/basin-delineation/#phase-1-outlet-identification","title":"Phase 1: Outlet Identification","text":"<p>Scan all cells to find outlets:</p> <pre><code>def find_outlets(fdr):\n    outlets = []\n\n    for cell in all_cells():\n        if is_nodata(fdr[cell]):\n            continue\n\n        downstream = get_downstream(cell, fdr)\n\n        if downstream is None or is_nodata(fdr[downstream]):\n            outlets.append(cell)\n\n    return outlets\n</code></pre>"},{"location":"algorithm-details/basin-delineation/#phase-2-upstream-labeling","title":"Phase 2: Upstream Labeling","text":"<p>For each outlet, propagate labels upstream using BFS:</p> <pre><code>def label_watersheds(fdr, drainage_points):\n    labels = zeros(fdr.shape, dtype=int64)\n    basin_graph = {}\n    queue = Queue()\n\n    # Start from all outlets\n    for outlet in find_outlets(fdr):\n        basin_id = generate_unique_id(outlet)\n        labels[outlet] = basin_id\n        queue.push((outlet, basin_id))\n\n    while not queue.empty():\n        cell, current_basin = queue.pop()\n\n        # Check if this cell is a drainage point\n        if cell in drainage_points:\n            new_basin = drainage_points[cell]\n            basin_graph[new_basin] = current_basin  # Record downstream connection\n            current_basin = new_basin\n\n        # Find and label upstream neighbors\n        for neighbor in neighbors_8(cell):\n            if labels[neighbor] != 0:\n                continue  # Already labeled\n\n            if not is_upstream(neighbor, cell, fdr):\n                continue  # Not flowing to current cell\n\n            labels[neighbor] = current_basin\n            queue.push((neighbor, current_basin))\n\n    return labels, basin_graph\n</code></pre>"},{"location":"algorithm-details/basin-delineation/#upstream-neighbor-generator","title":"Upstream Neighbor Generator","text":"<p>Iterate through neighbors and check if they flow to the current cell:</p> <pre><code>def upstream_neighbors(cell, fdr):\n    row, col = cell\n\n    for direction in range(8):\n        dr, dc = OFFSETS[direction]\n        neighbor = (row + dr, col + dc)\n\n        if out_of_bounds(neighbor):\n            continue\n\n        # Check if neighbor's flow direction points to cell\n        neighbor_direction = fdr[neighbor]\n        if neighbor_direction == NODATA or neighbor_direction == UNDEFINED:\n            continue\n\n        # Opposite direction should point back to cell\n        opposite = (direction + 4) % 8\n        if neighbor_direction == opposite:\n            yield neighbor\n</code></pre>"},{"location":"algorithm-details/basin-delineation/#drainage-point-handling","title":"Drainage Point Handling","text":""},{"location":"algorithm-details/basin-delineation/#coordinate-transformation","title":"Coordinate Transformation","text":"<p>Drainage points are typically provided in geographic coordinates. Convert to raster indices:</p> \\[ c = \\lfloor (x - x_0) / \\Delta x \\rfloor \\] \\[ r = \\lfloor (y_0 - y) / |\\Delta y| \\rfloor \\] <p>where \\((x_0, y_0)\\) is the raster origin and \\((\\Delta x, \\Delta y)\\) are pixel dimensions.</p>"},{"location":"algorithm-details/basin-delineation/#snapping-to-flow-accumulation","title":"Snapping to Flow Accumulation","text":"<p>Drainage points may not fall exactly on stream channels. Snapping moves them to the highest accumulation cell within a search radius:</p> <pre><code>def snap_to_stream(point, fac, radius):\n    best_cell = point\n    max_acc = fac[point]\n\n    for dr in range(-radius, radius + 1):\n        for dc in range(-radius, radius + 1):\n            cell = (point[0] + dr, point[1] + dc)\n\n            if fac[cell] &gt; max_acc:\n                max_acc = fac[cell]\n                best_cell = cell\n\n    return best_cell\n</code></pre>"},{"location":"algorithm-details/basin-delineation/#basin-id-assignment","title":"Basin ID Assignment","text":"<p>Each drainage point receives a unique basin ID. The graph records downstream relationships:</p> \\[ \\text{graph}[B_i] = B_j \\iff \\text{basin } B_i \\text{ drains to basin } B_j \\]"},{"location":"algorithm-details/basin-delineation/#basin-graph","title":"Basin Graph","text":"<p>The basin graph is a directed acyclic graph (DAG) representing drainage relationships:</p> <ul> <li>Vertices: Basin IDs</li> <li>Edges: Downstream connections</li> </ul> <p>For drainage points \\(D = \\{d_1, d_2, \\ldots, d_k\\}\\) with basin IDs \\(B = \\{b_1, b_2, \\ldots, b_k\\}\\):</p> \\[ (b_i, b_j) \\in E \\iff \\exists \\text{ flow path from } d_i \\text{ to } d_j \\]"},{"location":"algorithm-details/basin-delineation/#polygon-generation","title":"Polygon Generation","text":"<p>Convert labeled raster to vector polygons using boundary tracing.</p>"},{"location":"algorithm-details/basin-delineation/#boundary-cell-detection","title":"Boundary Cell Detection","text":"<p>A cell is on the basin boundary if any 8-connected neighbor has a different label:</p> \\[ \\text{is\\_boundary}(c) = \\exists n \\in N_8(c) : \\text{label}(n) \\neq \\text{label}(c) \\]"},{"location":"algorithm-details/basin-delineation/#moore-neighbor-tracing","title":"Moore-Neighbor Tracing","text":"<p>Trace the boundary of each basin using the Moore-Neighbor algorithm:</p> <ol> <li>Find a boundary cell (leftmost cell in topmost row)</li> <li>Start facing \"up\" (north)</li> <li>Turn clockwise until finding a cell with the same label</li> <li>Move to that cell, record its position</li> <li>Repeat until returning to the starting cell</li> </ol> <pre><code>def trace_boundary(start, labels, basin_id):\n    polygon = [start]\n    current = start\n    direction = 0  # Start facing up\n\n    while True:\n        # Search clockwise for next boundary cell\n        for i in range(8):\n            check_dir = (direction + 5 + i) % 8  # Start from back-left\n            neighbor = get_neighbor(current, check_dir)\n\n            if labels[neighbor] == basin_id:\n                current = neighbor\n                direction = check_dir\n                break\n\n        if current == start and len(polygon) &gt; 1:\n            break\n\n        polygon.append(current)\n\n    return polygon\n</code></pre> <p>Reference: Moore-Neighbor Tracing</p>"},{"location":"algorithm-details/basin-delineation/#tiled-processing","title":"Tiled Processing","text":"<p>For large rasters, basins are labeled per-tile and then connected:</p>"},{"location":"algorithm-details/basin-delineation/#phase-1-local-labeling","title":"Phase 1: Local Labeling","text":"<p>Each tile runs the watershed labeling algorithm independently:</p> <ul> <li>Labels offset by tile index to ensure uniqueness</li> <li>Perimeter cells recorded for cross-tile connection</li> </ul>"},{"location":"algorithm-details/basin-delineation/#phase-2-cross-tile-connection","title":"Phase 2: Cross-Tile Connection","text":"<p>Examine adjacent tile boundaries:</p> <p>For tiles \\(A\\) and \\(B\\) sharing an edge, for each pair of adjacent cells \\((a, b)\\):</p> <pre><code>if fdr[a] points to b:\n    graph[labels[a]] = labels[b]\nelif fdr[b] points to a:\n    graph[labels[b]] = labels[a]\n</code></pre>"},{"location":"algorithm-details/basin-delineation/#phase-3-label-finalization","title":"Phase 3: Label Finalization","text":"<p>Walk the graph to assign final basin IDs:</p> <pre><code>def finalize_labels(labels, graph, drainage_points):\n    # Find final basin for each intermediate label\n    final_basin = {}\n\n    for label in all_labels:\n        current = label\n\n        while current in graph and current not in drainage_points:\n            current = graph[current]\n\n        final_basin[label] = current\n\n    # Apply final labels\n    for cell in all_cells():\n        if labels[cell] in final_basin:\n            labels[cell] = final_basin[labels[cell]]\n</code></pre>"},{"location":"algorithm-details/basin-delineation/#output-modes","title":"Output Modes","text":""},{"location":"algorithm-details/basin-delineation/#drainage-point-basins-only","title":"Drainage Point Basins Only","text":"<p>Label only cells draining to specified drainage points. Other cells receive nodata.</p>"},{"location":"algorithm-details/basin-delineation/#all-basins","title":"All Basins","text":"<p>Label all cells, including those draining off-map:</p> \\[ \\text{label}(c) = \\begin{cases} b_i &amp; \\text{if } c \\text{ drains to drainage point } d_i \\\\ \\text{outlet\\_id}(c) &amp; \\text{if } c \\text{ drains off-map} \\end{cases} \\]"},{"location":"algorithm-details/basin-delineation/#complexity","title":"Complexity","text":"<p>Let \\(n\\) be total cells and \\(d\\) be drainage point count.</p> Operation Time Complexity Outlet finding \\(O(n)\\) Upstream BFS \\(O(n)\\) Graph walking \\(O(d)\\) Polygon tracing \\(O(p)\\) <p>Where \\(p\\) is total boundary perimeter.</p>"},{"location":"algorithm-details/basin-delineation/#see-also","title":"See Also","text":"<ul> <li>Flow Direction - Computing flow directions</li> <li>Stream Extraction - Generating drainage points at junctions</li> <li>Flow Length - Computing flow path lengths within basins</li> </ul>"},{"location":"algorithm-details/breach/","title":"Breach Algorithm","text":""},{"location":"algorithm-details/breach/#overview","title":"Overview","text":"<p>The breach algorithm removes depressions from a DEM by carving flow paths through elevation barriers. The algorithm reads the input DEM and writes a modified output DEM with lowered cell elevations that create monotonic drainage paths from pits to outlets.</p> <p>The implementation uses two complementary strategies. First, a fast single-cell method handles simple pits by modifying one intermediate cell. Second, a Dijkstra-based least-cost pathfinding approach handles complex, multi-cell depressions that the single-cell method cannot resolve.</p> <p>For large rasters, the algorithm processes the DEM in tiles. Each tile is read with a buffer region to ensure cells near tile edges can access their full neighborhood. Tiles are modified in memory, and only the unbuffered interior is written to the output.</p>"},{"location":"algorithm-details/breach/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>A cell \\(c\\) with elevation \\(z_c\\) is a pit if all 8-connected neighbors have elevation greater than or equal to \\(z_c\\), and at least one neighbor is strictly higher:</p> \\[ \\text{is\\_pit}(c) = \\left(\\forall n \\in N(c): z_n \\geq z_c\\right) \\land \\left(\\exists n \\in N(c): z_n &gt; z_c\\right) \\] <p>where \\(N(c)\\) denotes the 8-connected neighborhood. This definition excludes flat regions where all neighbors have equal elevation:</p> \\[ \\text{is\\_flat}(c) = \\forall n \\in N(c): z_n = z_c \\] <p>A breach path is a sequence of cells \\(P = [p_1, p_2, \\ldots, p_k]\\) connecting a pit to a drainage point. The algorithm modifies elevations along this path to create monotonic descent.</p>"},{"location":"algorithm-details/breach/#data-types-and-structures","title":"Data Types and Structures","text":""},{"location":"algorithm-details/breach/#inputoutput-types","title":"Input/Output Types","text":"Parameter Type Description No-Data Value input_dem float32 Input elevation raster user-defined or NaN output_dem float32 Output elevation raster with breached pits user-defined or NaN search_radius int Maximum search distance for least-cost paths (cells) N/A"},{"location":"algorithm-details/breach/#internal-structures","title":"Internal Structures","text":"Structure Type Purpose unsolved_pits_raster int8 2D array Marks cells as pits (1) or solved/non-pit (0) costs_array float32 2D array Accumulated path cost, size \\((2r+1)^2\\) per pit prev_rows_array int64 2D array Row index of predecessor in path, size \\((2r+1)^2\\) per pit prev_cols_array int64 2D array Column index of predecessor in path, size \\((2r+1)^2\\) per pit Priority queue (heap) GridCell list Min-heap storing (cost, row, col) for Dijkstra's algorithm"},{"location":"algorithm-details/breach/#constants","title":"Constants","text":"Constant Value Purpose EPSILON_GRADIENT <code>1e-5</code> Minimum elevation drop per cell when breaching to nodata DEFAULT_SEARCH_RADIUS <code>200</code> Default maximum search distance for least-cost breaching (cells) UNVISITED_INDEX <code>-1</code> Sentinel value indicating unvisited cell in path reconstruction"},{"location":"algorithm-details/breach/#algorithm","title":"Algorithm","text":"<p>The breach algorithm operates in two phases. The single-cell phase handles simple pits quickly. Pits that remain unsolved are passed to the least-cost phase.</p>"},{"location":"algorithm-details/breach/#processing-model","title":"Processing Model","text":"<p>The input DEM is divided into tiles for large rasters. For each tile, both breach phases are applied sequentially on the same in-memory data before writing to output:</p> <ol> <li>Read tile from input (with buffer sized to search radius)</li> <li>Apply single-cell breaching to the tile in memory (modifies tile data)</li> <li>Apply least-cost breaching to the same modified tile in memory</li> <li>Write the final result to output (unbuffered interior only)</li> </ol> <p>The loop structure <code>for row in range(2, rows - 2)</code> processes cells starting at index 2 and ending at <code>rows - 3</code> (inclusive). This excludes the buffer on all edges. The same applies for columns. The buffer size for least-cost breaching equals the search radius to ensure pits near tile edges can search their full window.</p> <p>Tiles are processed in parallel. Each tile operates on its own memory region, with both phases applied to the same tile data before writing.</p>"},{"location":"algorithm-details/breach/#phase-1-single-cell-pit-detection","title":"Phase 1: Single-Cell Pit Detection","text":"<p>The algorithm scans the interior region of each tile to identify pits. A cell is marked as a pit if all 8 neighbors have elevation greater than or equal to the cell, and at least one neighbor is strictly higher. Flat cells are explicitly excluded from being marked as pits.</p> <pre><code>def identify_single_cell_pits(dem: float32[rows, cols], nodata_value: float) -&gt; int8[rows, cols]:\n    \"\"\"Identify single-cell pits in interior region (excluding 2-cell border)\"\"\"\n    unsolved_pits = zeros((rows, cols), dtype=int8)\n\n    for row in range(2, rows - 2):\n        for col in range(2, cols - 2):\n            z = dem[row, col]\n            if z == nodata_value or isnan(z):\n                continue\n\n            is_flat = True\n            is_sink = True\n\n            # Check 8-connected neighbors\n            for (dy, dx) in NEIGHBOR_OFFSETS:\n                zn = dem[row + dy, col + dx]\n                if zn != z:\n                    is_flat = False\n                # Sink check: any neighbor lower or nodata breaks sink status\n                if zn == nodata_value or isnan(zn) or zn &lt; z:\n                    is_sink = False\n                    break\n\n            if not is_flat and is_sink:\n                unsolved_pits[row, col] = 1\n\n    return unsolved_pits\n</code></pre> <p>Flat Cells Are Not Pits</p> <p>Cells where all neighbors have equal elevation are explicitly excluded. Only true pits (all neighbors higher) and cells on the edge of a flat region (some equal, some higher, none lower) are marked as pits.</p> <p>The function returns an int8 array marking pit cells. The nodata check occurs first. If a cell is nodata or NaN, it is skipped entirely. During neighbor checking, nodata neighbors are treated as being lower than the current cell elevation. This breaks the sink condition, so cells adjacent to nodata are not marked as pits. However, during resolution, nodata cells can be valid breach targets.</p>"},{"location":"algorithm-details/breach/#phase-2-single-cell-pit-resolution","title":"Phase 2: Single-Cell Pit Resolution","text":"<p>For each identified pit, the algorithm searches a 16-cell neighborhood at radius 2 for a breach target. The target must have elevation less than or equal to the pit elevation, or be nodata. When a target is found, the intermediate cell between the pit and target is modified.</p> <pre><code>def resolve_single_cell_pits(dem: float32[rows, cols],\n                              unsolved_pits: int8[rows, cols],\n                              nodata_value: float) -&gt; int8[rows, cols]:\n    \"\"\"Breach pits within 16-neighbor window by modifying intermediate cell\"\"\"\n    # 16-neighbor offsets at radius 2\n    dx2 = [2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1]\n    dy2 = [-2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2]\n    # Intermediate cell mapping: breachcell[k] gives 8-neighbor index\n    breachcell = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 0]\n\n    pit_indices = argwhere(unsolved_pits == 1)\n\n    for (row, col) in pit_indices:\n        z = dem[row, col]\n        for k in range(16):\n            zn = dem[row + dy2[k], col + dx2[k]]\n\n            # Breach target: lower or equal elevation, or nodata\n            if zn &lt;= z or zn == nodata_value or isnan(zn):\n                if zn == nodata_value or isnan(zn):\n                    # Breaching to nodata: apply small gradient\n                    zn = z - 2 * EPSILON_GRADIENT\n\n                # Modify intermediate cell\n                intermediate = breachcell[k]\n                dem[row + dy[intermediate], col + dx[intermediate]] = (z + zn) / 2\n                unsolved_pits[row, col] = 0  # Mark as solved\n                break\n\n    return unsolved_pits\n</code></pre> <p>The intermediate cell elevation is set to the average of the pit and target elevations: \\((z_c + z_t) / 2\\). This ensures the intermediate cell is lower than the pit but higher than the target, preventing the creation of new pits or uphill flow segments.</p> <p>When breaching to a nodata cell, the target elevation is set to \\(z - 2 \\cdot \\epsilon\\). The factor of 2 ensures that when the intermediate cell takes the average \\((z + (z - 2\\epsilon))/2 = z - \\epsilon\\), the resulting elevation is below the pit by at least one epsilon. This guarantees flow can continue through the pit.</p> <p>If no valid breach target is found within the 16-neighbor window, the pit remains in the unsolved_pits_raster with value 1. These pits are passed to the least-cost phase.</p> <p>The <code>for (row, col) in pit_indices</code> loop iterates over all pits identified in phase 1. Within a single tile, <code>argwhere</code> returns indices in row-major order (top-to-bottom, left-to-right), so pit processing is deterministic. This loop executes sequentially (not parallelized within the tile).</p>"},{"location":"algorithm-details/breach/#phase-3-least-cost-path-breaching","title":"Phase 3: Least-Cost Path Breaching","text":"<p>Pits that remain unsolved after single-cell resolution are breached using Dijkstra's algorithm. The algorithm searches within a square window of size \\((2r+1) \\times (2r+1)\\) centered on the pit, where \\(r\\) is the search radius.</p>"},{"location":"algorithm-details/breach/#cost-function","title":"Cost Function","text":"<p>The cost to move from cell \\(c\\) to neighbor \\(n\\) is based on elevation difference relative to the pit elevation:</p> \\[ \\text{cost}(c \\to n) = w_{c,n} \\cdot (z_n - z_{\\text{pit}}) \\] <p>where \\(z_{\\text{pit}}\\) is the elevation of the pit cell (constant throughout the search), and \\(w_{c,n}\\) is the distance weight:</p> \\[ w_{c,n} = \\begin{cases} 1.0 &amp; \\text{cardinal directions (N, S, E, W)} \\\\ \\sqrt{2} &amp; \\text{diagonal directions (NE, NW, SE, SW)} \\end{cases} \\] <p>Descending terrain produces negative edge costs because \\(z_n &lt; z_{\\text{pit}}\\). Dijkstra's algorithm handles negative costs correctly as long as there are no negative cycles. Paths preferentially follow valleys (negative costs accumulate to large negative total cost) rather than ridges (positive costs).</p> <p>No-data cells are assigned elevation \\(-\\infty\\). When a neighbor is nodata, the edge cost calculation checks for this special value and uses zero cost instead of a very large negative number. This makes nodata cells strong attractors for breach paths without causing numerical overflow.</p>"},{"location":"algorithm-details/breach/#dijkstra-search","title":"Dijkstra Search","text":"<pre><code>def breach_pit_least_cost(pit_row: int, pit_col: int,\n                          dem: float32[rows, cols],\n                          nodata_value: float,\n                          search_radius: int) -&gt; None:\n    \"\"\"Find and apply least-cost breach path using Dijkstra's algorithm\"\"\"\n    initial_elevation = dem[pit_row, pit_col]\n\n    # Initialize cost grid (size = search window)\n    window_size = 2 * search_radius + 1\n    costs = full((window_size, window_size), inf, dtype=float32)\n    prev_rows = full((window_size, window_size), UNVISITED_INDEX, dtype=int64)\n    prev_cols = full((window_size, window_size), UNVISITED_INDEX, dtype=int64)\n\n    # Offsets to convert global coords to window coords\n    row_offset = search_radius - pit_row\n    col_offset = search_radius - pit_col\n\n    # Initialize pit\n    costs[pit_row + row_offset, pit_col + col_offset] = 0\n    heap = MinHeap()\n    heap.push((0.0, pit_row, pit_col))\n\n    while not heap.empty():\n        cost, row, col = heap.pop()\n\n        # Check termination: found drainage point\n        elevation = dem[row, col]\n        if elevation == nodata_value or isnan(elevation):\n            elevation = -inf\n        if elevation &lt; initial_elevation or elevation == -inf:\n            # Reconstruct and apply path\n            reconstruct_path(row, col, elevation, initial_elevation, dem,\n                           prev_rows, prev_cols, row_offset, col_offset)\n            return\n\n        # Process 8-connected neighbors\n        for direction in range(8):\n            dy, dx = NEIGHBOR_OFFSETS[direction]\n            nr, nc = row + dy, col + dx\n\n            # Bounds check: within DEM and search window\n            if not (0 &lt;= nr &lt; rows and 0 &lt;= nc &lt; cols):\n                continue\n            if abs(nr - pit_row) &gt; search_radius or abs(nc - pit_col) &gt; search_radius:\n                continue\n\n            # Calculate cost\n            multiplier = sqrt(2) if is_diagonal(direction) else 1.0\n            neighbor_elevation = dem[nr, nc]\n            if neighbor_elevation == nodata_value or isnan(neighbor_elevation):\n                neighbor_elevation = -inf\n\n            if neighbor_elevation != -inf:\n                edge_cost = multiplier * (neighbor_elevation - initial_elevation)\n            else:\n                edge_cost = 0  # No additional cost for nodata\n\n            new_cost = cost + edge_cost\n\n            # Update if better path found\n            if new_cost &lt; costs[nr + row_offset, nc + col_offset]:\n                costs[nr + row_offset, nc + col_offset] = new_cost\n                prev_rows[nr + row_offset, nc + col_offset] = row\n                prev_cols[nr + row_offset, nc + col_offset] = col\n                heap.push((new_cost, nr, nc))\n\n    # No path found within search radius (pit remains)\n</code></pre> <p>The algorithm terminates when it pops a cell from the heap that has elevation less than the pit elevation, or is nodata. This cell is the breach point. If the heap empties without finding such a cell, the pit cannot be breached within the search radius and remains unmodified.</p> <p>Each pit allocates its own cost and predecessor arrays of size \\((2r+1)^2\\). Different pits never share these arrays, even if their search windows overlap spatially in the DEM.</p> <p>When multiple paths to a cell have the same cost, Dijkstra's algorithm selects whichever path reaches the cell first based on heap extraction order. All such paths are equally valid by the cost metric.</p>"},{"location":"algorithm-details/breach/#phase-4-path-reconstruction-and-gradient-application","title":"Phase 4: Path Reconstruction and Gradient Application","text":"<p>Once a breach point is found, the path from the breach point back to the pit is reconstructed by following the predecessor pointers. The path is then used to apply a linear elevation gradient.</p> <pre><code>def reconstruct_path(breach_row: int, breach_col: int,\n                     final_elevation: float,\n                     init_elevation: float,\n                     dem: float32[rows, cols],\n                     prev_rows: int64[window, window],\n                     prev_cols: int64[window, window],\n                     row_offset: int, col_offset: int) -&gt; None:\n    \"\"\"Trace path and apply gradient\"\"\"\n    # Build path from breach point to pit\n    path = []\n    row, col = breach_row, breach_col\n    while prev_rows[row + row_offset, col + col_offset] != UNVISITED_INDEX:\n        path.append((row, col))\n        row = prev_rows[row + row_offset, col + col_offset]\n        col = prev_cols[row + row_offset, col + col_offset]\n\n    # Remove last cell (pit itself should not be modified)\n    path.pop()\n    path_length = len(path)\n\n    # Apply gradient along path\n    if final_elevation == -inf:\n        # Case A: Breaching to nodata\n        for j, (r, c) in enumerate(path):\n            if j &gt; 0:  # Skip first cell (already at breach point)\n                gradient_elev = init_elevation - (path_length - j) * EPSILON_GRADIENT\n                dem[r, c] = min(gradient_elev, dem[r, c])\n    else:\n        # Case B: Breaching to valid terrain\n        for j, (r, c) in enumerate(path):\n            # Skip flat areas (already at correct elevation)\n            if dem[r, c] == init_elevation:\n                continue\n            # Linear interpolation from breach point to pit\n            gradient_elev = final_elevation + (init_elevation - final_elevation) * j / path_length\n            dem[r, c] = min(gradient_elev, dem[r, c])\n</code></pre> <p>The gradient is applied using linear interpolation between the breach point elevation and the pit elevation. The path list is ordered from breach point to pit (index 0 is breach point, last index is pit). The interpolation parameter \\(j / \\text{path\\_length}\\) ranges from 0 at the breach point to 1 near the pit.</p> <p>Always Use min() in Gradient Application</p> <p>The min() operation <code>dem[r, c] = min(gradient_elev, dem[r, c])</code> is critical. It prevents raising elevations above their original values. This preserves ridges along the path and prevents the creation of uphill flow segments. Without min(), the gradient could raise cells that are already lower than the interpolated value, creating artificial barriers.</p> <p>When breaching to nodata (final_elevation is \\(-\\infty\\)), the gradient starts from the pit elevation and decreases by epsilon for each cell along the path away from the pit. The first cell in the path (the nodata cell itself) is skipped because it should not be modified.</p> <p>When breaching to valid terrain, cells that already have elevation equal to the pit elevation are skipped. These are flat regions that should not be modified by the gradient. The path may traverse through such flats, and modifying them could create unintended barriers.</p> <p>The pit cell itself is excluded from the path before gradient application (via <code>path.pop()</code>). The pit's original elevation is preserved.</p>"},{"location":"algorithm-details/breach/#multiple-pit-processing-and-path-interactions","title":"Multiple Pit Processing and Path Interactions","text":"<p>Within a single tile, pits are processed sequentially in row-major order (top-to-bottom, left-to-right). This ordering is deterministic because <code>argwhere</code> always returns indices in the same order for a given input.</p> <p>When an earlier pit is breached before a later pit, the later pit's Dijkstra search operates on the DEM that already includes the earlier breach modifications. If an earlier pit creates a breach path that lowers terrain, later pits will see those lowered elevations during their cost calculations. A later pit may find a shorter or cheaper path by routing through terrain already lowered by an earlier breach, as the cost function naturally guides searches toward these lowered areas.</p> <p>The <code>min()</code> operation in gradient application ensures that if multiple breach paths cross the same cell, that cell receives the minimum (most lowered) elevation from all breaches. Breaches only lower terrain, never raise it, so no conflicts occur between paths.</p> <p>Different pit orderings could produce different final DEMs. However, row-major ordering is consistent across runs, making results fully reproducible. All breach paths remain valid (monotonically decreasing from pit to outlet) regardless of order.</p> <p>This sequential processing within tiles is distinct from tile-level parallelism, where different tiles process independently and write to non-overlapping output regions.</p>"},{"location":"algorithm-details/breach/#visual-walkthrough","title":"Visual Walkthrough","text":""},{"location":"algorithm-details/breach/#figure-1-single-cell-pit-detection-pattern","title":"Figure 1: Single-Cell Pit Detection Pattern","text":"<pre><code>8-neighbor pit detection:\n\n    Neighbor indices:     Elevation check:\n\n     3  |  2  |  1           &gt;= | &gt;= | &gt;=\n    ----|-----|----         ----|----|----\n     4  |  c  |  0           &gt;= | zc | &gt;=\n    ----|-----|----         ----|----|----\n     5  |  6  |  7           &gt;= | &gt;= | &gt;=\n\n    Pit: ALL neighbors &gt;= zc AND at least one &gt; zc\n\n16-neighbor breach search:\n\n     .  .  .  .  .\n     .  x  x  x  .\n     .  x  c  x  .\n     .  x  x  x  .\n     .  .  .  .  .\n\n    Search 16 outer cells (.) for elevation &lt;= zc\n    Modify intermediate cell (x) to create path\n</code></pre>"},{"location":"algorithm-details/breach/#figure-2-least-cost-breach-algorithm-flow","title":"Figure 2: Least-Cost Breach Algorithm Flow","text":"<pre><code>graph TD\n    A[Start: Pit at zc] --&gt; B[Initialize cost grid to \u221e]\n    B --&gt; C[Set pit cost = 0]\n    C --&gt; D[Push pit to heap]\n    D --&gt; E{Heap empty?}\n    E --&gt;|Yes| F[No path found within radius]\n    E --&gt;|No| G[Pop min cost cell]\n    G --&gt; H{Cell elevation &lt; zc OR nodata?}\n    H --&gt;|Yes| I[Reconstruct path]\n    I --&gt; J[Apply linear gradient]\n    J --&gt; K[End: Pit breached]\n    H --&gt;|No| L[Process 8 neighbors]\n    L --&gt; M{Better path found?}\n    M --&gt;|Yes| N[Update cost &amp; prev]\n    N --&gt; O[Push to heap]\n    M --&gt;|No| P[Skip neighbor]\n    O --&gt; E\n    P --&gt; E\n</code></pre>"},{"location":"algorithm-details/breach/#figure-3-breach-path-visualization","title":"Figure 3: Breach Path Visualization","text":"Before Breach After Breach <p>The pit at cell (3,3) has elevation 98.0 and is surrounded by higher terrain. The breach path (highlighted in red) connects the pit diagonally to lower terrain at cell (6,6) with elevation 96.0. After breaching, cells along the path are lowered to create a monotonic descent: 98.0 -&gt; 97.3 -&gt; 96.7 -&gt; 96.0.</p>"},{"location":"algorithm-details/breach/#no-data-handling","title":"No-Data Handling","text":"<p>The algorithm checks for both explicit nodata values and NaN at every operation: <code>z == nodata_value or np.isnan(z)</code>. Both representations are treated identically throughout.</p> <p>During pit detection, nodata cells are skipped entirely. They are never marked as pits. When checking neighbors of a cell to determine if the cell is a pit, nodata neighbors are treated as being lower than the current cell. This breaks the sink condition, so cells adjacent to nodata are not marked as pits during detection.</p> <p>During pit resolution, nodata cells can be valid breach targets. If a nodata cell is found within the 16-neighbor window, the algorithm uses the target elevation \\(z - 2\\epsilon\\) when computing the intermediate cell elevation. This ensures proper gradient even when breaching toward nodata.</p> <p>During least-cost search, nodata cells are assigned elevation \\(-\\infty\\). This makes them strong attractors for breach paths. The edge cost to a nodata cell is set to zero (rather than attempting to compute a cost from \\(-\\infty\\)) to avoid numerical issues.</p> <p>Input nodata cells are copied to the output unchanged. The output DEM preserves all nodata cells from the input in their original locations. Breached cells receive modified float32 elevations in the output.</p>"},{"location":"algorithm-details/breach/#edge-cases-and-boundary-conditions","title":"Edge Cases and Boundary Conditions","text":""},{"location":"algorithm-details/breach/#raster-boundaries-and-buffer-zones","title":"Raster Boundaries and Buffer Zones","text":"<p>The single-cell algorithm processes only the interior region of each tile. The loop <code>for row in range(2, rows - 2)</code> starts at row 2 and ends at row <code>rows - 3</code> (inclusive). This excludes a 2-cell border on all edges. The buffer must be at least 2 cells because the 16-neighbor search window extends 2 cells in each direction. In practice, the buffer size equals the search radius (typically much larger than 2) to accommodate the least-cost phase.</p> <p>When tiles are read from the raster, a buffer equal to the search radius is included on all sides. For tiles in the interior of the raster, this buffer is populated with actual DEM data from adjacent regions. For tiles at the global raster boundary, portions of the buffer that extend beyond the raster extent are filled with nodata values. These out-of-bounds cells are not treated specially by the algorithm; they exist as regular array cells with nodata values.</p> <p>Cells near the global raster boundary that are pits may breach to the nodata-filled buffer regions. Since nodata is treated as the lowest possible elevation (see Phase 2), pits near raster edges naturally drain toward the boundary. This is hydrologically correct for most DEMs where the raster edge represents a drainage outlet or boundary condition. After both breach phases complete, only the unbuffered interior is written to the output.</p>"},{"location":"algorithm-details/breach/#unsolved-pits-after-single-cell-phase","title":"Unsolved Pits After Single-Cell Phase","text":"<p>If a pit has no valid breach target within its 16-neighbor window, it remains marked in the unsolved_pits_raster with value 1. These pits are passed to the least-cost phase. In practice, complex depressions spanning many cells, and large flat areas, cannot be resolved by the single-cell method and require the least-cost approach.</p>"},{"location":"algorithm-details/breach/#search-radius-limitations","title":"Search Radius Limitations","text":"<p>The least-cost search operates within a square window of size \\((2r+1) \\times (2r+1)\\) centered on the pit. If no drainage point is found within this window, the algorithm terminates and the pit remains unbreached. Increasing the search radius provides more completeness but consumes more memory. Each pit allocates \\((2r+1)^2\\) cells for cost and predecessor arrays. For very large radii or many pits, memory usage can become substantial.</p> <p>For depressions larger than the search radius, the fill algorithm may be more appropriate, as it guarantees complete removal of all depressions.</p>"},{"location":"algorithm-details/breach/#cost-overflow-and-numerical-stability","title":"Cost Overflow and Numerical Stability","text":"<p>Cost calculations use float32. For very large search radii or extreme elevation ranges, the accumulated cost can overflow or lose precision. Intermediate cost calculations may use float64 for stability, but the final stored cost is float32. Elevation differences near machine epsilon (approximately \\(10^{-7}\\) for float32) may produce unexpected behavior due to rounding.</p>"},{"location":"algorithm-details/breach/#tiled-processing","title":"Tiled Processing","text":"<p>The DEM is divided into square tiles for large rasters. Each tile is processed independently with a buffer region to ensure correct results near tile boundaries.</p>"},{"location":"algorithm-details/breach/#tile-structure","title":"Tile Structure","text":"<p>A tile of size \\(s \\times s\\) is read with a buffer of size \\(r\\) (the search radius) on all edges. The full tile including buffer has size \\((s + 2r) \\times (s + 2r)\\). The buffer size equals the search radius to ensure that least-cost searches from pits near tile edges can access their full search window. After both phases complete, only the interior region (excluding buffer) is written to output.</p> <p>The buffer is populated with actual DEM data from the input raster. For tiles at the global raster boundary, buffer regions that extend beyond the raster extent are filled with nodata values. These cells are not inaccessible or out-of-bounds in the implementation; they exist in the tile array as valid cells with nodata values. This allows neighbor checks and searches to proceed uniformly without special boundary logic.</p>"},{"location":"algorithm-details/breach/#processing-phases","title":"Processing Phases","text":"<p>Each tile follows a four-step pipeline. The tile is read from input with a buffer equal to the search radius. Then <code>breach_single_cell_pits_in_chunk</code> modifies the tile data in memory and returns an unsolved pits array. Next, <code>breach_all_pits_in_chunk_least_cost</code> operates on the same (now modified) tile data in memory, breaching remaining pits. Finally, the result is written to output, but only the unbuffered interior is written.</p> <p>Both phases work on the same in-memory tile. The single-cell phase modifies the tile first, then the least-cost phase works on that modified data. Only after both phases complete is the tile written to disk.</p>"},{"location":"algorithm-details/breach/#parallel-execution","title":"Parallel Execution","text":"<p>Tiles are processed concurrently using a thread pool. Each tile is read from input, processed in its own memory region, and written to output independently. Different threads may write to the same output file, but they write to non-overlapping spatial regions (tile boundaries do not overlap). The least-cost phase allocates separate cost and predecessor arrays for each pit, eliminating shared state between threads.</p> <p>No synchronization is required between tiles during processing. Each tile can be processed completely independently. However, pits located near tile boundaries require careful consideration.</p> <p>Buffer Size Equals Search Radius</p> <p>The tile buffer size equals the search radius. This ensures pits near tile edges have access to their full search window within the buffered tile. The search window for any pit in the interior fits entirely within the tile plus buffer.</p>"},{"location":"algorithm-details/breach/#tile-boundary-considerations","title":"Tile Boundary Considerations","text":"<p>Pits located near tile boundaries present a special case. A pit at the edge of one tile's interior may also appear in a neighboring tile's buffer region. Both tiles will independently identify and breach this pit, potentially finding different paths.</p> <p>The same pit is breached independently by both tiles, with each breach operating on its own copy of the DEM data. Only the tile where the pit is located in the interior writes that pit's breach to output. The neighboring tile does not write its buffer region, so its version of the breach is partially discarded.</p> <p>If a pit near a tile boundary breaches toward the neighboring tile, the breach path may extend into the buffer region, but the portion in the buffer is not written. If the neighboring tile also breaches toward its interior from its buffer region (where the same terrain appears), different breach decisions may result in artifacts at the tile boundary.</p> <p>These edge effects can produce incomplete breach paths or elevation discontinuities at tile boundaries where breach paths cross from one tile's interior to another's. Pits near boundaries that breach in one direction may have only partial paths written, leaving residual depressions. This is one reason why depression filling is applied after breaching to ensure a complete, hydrologically-connected surface.</p> <p>Different chunk sizes will produce different tile boundary locations, which can result in different breach paths for pits near those boundaries. However, for a given chunk size, results are deterministic and reproducible across runs.</p>"},{"location":"algorithm-details/breach/#properties-and-guarantees","title":"Properties and Guarantees","text":"<p>Every breached cell has a non-increasing path to a drainage point. Following steepest descent from any breached cell leads to a cell with elevation less than or equal to the current cell at each step. Only cells on breach paths are modified, with elevations lowered via the min() operation, never raised. Cells not on any breach path retain their original elevations.</p> <p>Least-cost paths minimize \\(\\sum w \\cdot (z - z_{\\text{pit}})\\) within the search radius. The path selected is optimal by this metric among all paths within the search window. However, pits beyond the search radius may remain unbreached. The algorithm does not guarantee a depression-free DEM, which is by design to limit memory usage and computation time.</p> <p>Formally, for breached elevation \\(z'\\):</p> \\[ z'_c \\leq z_c \\quad \\forall c \\in \\text{modified cells} \\] <p>For cells on breach paths:</p> \\[ \\exists \\text{ path } P = [c, p_1, \\ldots, p_k] : z'_{p_i} \\leq z'_{p_{i-1}} \\quad \\forall i \\]"},{"location":"algorithm-details/breach/#complexity-analysis","title":"Complexity Analysis","text":"<p>Let \\(n\\) be the total number of cells, \\(p\\) the number of pits, and \\(r\\) the search radius.</p> Metric Single-Tile Tiled Time \\(O(n + p \\cdot r^2 \\log r)\\) \\(O(n + p \\cdot r^2 \\log r)\\) Space \\(O(n + r^2)\\) \\(O(s^2 + r^2)\\) per tile"},{"location":"algorithm-details/breach/#time-complexity-breakdown","title":"Time Complexity Breakdown","text":"Operation Time Complexity Notes Single-cell pit detection \\(O(n)\\) 8-neighbor check per cell Single-cell resolution \\(O(p)\\) 16-neighbor search per pit (amortized constant) Least-cost per pit \\(O(r^2 \\log r)\\) Dijkstra on \\((2r+1)^2\\) window Path reconstruction \\(O(r)\\) Linear trace per pit Total \\(O(n + p \\cdot r^2 \\log r)\\) Dominated by Dijkstra when many pits exist <p>The worst case occurs when every cell is a pit (\\(p = n\\)), yielding \\(O(n \\cdot r^2 \\log r)\\). In practice, pits are rare and \\(p \\ll n\\) (typically less than 1% of cells).</p>"},{"location":"algorithm-details/breach/#space-complexity","title":"Space Complexity","text":"<p>Each pit allocates \\((2r+1)^2\\) cells for cost and predecessor arrays. For large \\(r\\), memory usage is \\(O(p \\cdot r^2)\\). If memory is constrained, pits can be processed sequentially rather than in parallel, reducing the peak memory requirement to \\(O(r^2)\\) (one pit at a time).</p> <p>For tiled processing, each tile holds \\(s^2\\) cells plus a \\(r^2\\) cost array per pit being processed. Multiple tiles in memory simultaneously scales this.</p>"},{"location":"algorithm-details/breach/#implementation-notes","title":"Implementation Notes","text":""},{"location":"algorithm-details/breach/#thread-safety","title":"Thread Safety","text":"<p>The single-cell phase processes tiles in memory. Each tile is a separate memory region (loaded from input), so different threads operate on distinct arrays. When writing to output, threads write to non-overlapping spatial regions determined by tile boundaries (excluding the buffer, which is not written). This prevents data races.</p> <p>The least-cost phase allocates separate cost and predecessor arrays for each pit. These arrays are not shared between pits, so no synchronization is needed. Each pit's search is completely independent. Reads from the input DEM are thread-safe (GDAL read operations). All write operations acquire a lock before writing to the dataset.</p>"},{"location":"algorithm-details/breach/#numerical-precision","title":"Numerical Precision","text":"<p>Intermediate calculations for cost and gradient use float64 for stability, but the input and output DEM is float32. Elevation differences smaller than float32 epsilon (approximately \\(10^{-7}\\)) may be rounded to zero, causing unexpected behavior when determining whether a neighbor is lower than the current cell.</p> <p>The epsilon gradient (1e-5) is several orders of magnitude larger than float32 epsilon, so gradient application is numerically stable for typical elevation ranges.</p>"},{"location":"algorithm-details/breach/#memory-scaling-with-search-radius","title":"Memory Scaling with Search Radius","text":"<p>Cost arrays scale as \\((2r+1)^2\\). For \\(r=100\\), each pit allocates approximately 160 KB (float32 costs plus two int64 predecessor arrays). For \\(r=1000\\), each pit requires approximately 16 MB. When processing many pits in parallel, total memory usage can be substantial. For large radii, consider processing pits sequentially or using a smaller search radius.</p>"},{"location":"algorithm-details/breach/#additional-considerations","title":"Additional Considerations","text":"<p>Breaching typically leaves residual small pits or flat regions that were beyond the search radius or required more complex resolution. Following breach with the fill algorithm ensures complete depression removal.</p> <p>The epsilon gradient magnitude (1e-5) assumes elevation units are meters or feet. For elevation data in other units (e.g., millimeters), adjust the constant proportionally.</p>"},{"location":"algorithm-details/breach/#limitations","title":"Limitations","text":"<p>Pits beyond the search radius remain unbreached. The algorithm does not guarantee a depression-free DEM. For applications requiring complete depression removal, use the fill algorithm or increase the search radius (with corresponding memory cost).</p> <p>The search radius is constant for all pits. Adaptive search (varying radius based on pit depth or context) could improve efficiency but is not implemented.</p> <p>The algorithm assumes each pit has one primary drainage point. Complex depressions with multiple potential outlets may produce suboptimal results depending on which outlet is found first.</p>"},{"location":"algorithm-details/breach/#see-also","title":"See Also","text":"<ul> <li>Fill Algorithm - Alternative approach that raises elevations to remove all depressions completely</li> <li>Flow Direction - Downstream processing that requires a depression-free DEM</li> <li>Flat Resolution - Resolves undefined flow in flat regions created by breaching</li> </ul>"},{"location":"algorithm-details/fill/","title":"Fill Algorithm","text":""},{"location":"algorithm-details/fill/#overview","title":"Overview","text":"<p>The fill algorithm eliminates depressions by raising cell elevations to the lowest pour point. It implements the Priority-Flood algorithm, a well-established technique for depression filling in digital elevation models.</p>"},{"location":"algorithm-details/fill/#references","title":"References","text":"<ul> <li> <p>Barnes, R., Lehman, C., Mulla, D. (2014). \"Priority-Flood: An Optimal Depression-Filling and Watershed-Labeling Algorithm for Digital Elevation Models.\" Computers &amp; Geosciences, 62, 117-127. arXiv:1511.04463</p> </li> <li> <p>Barnes, R. (2016). \"Parallel Priority-Flood Depression Filling For Trillion Cell Digital Elevation Models On Desktops Or Clusters.\" Computers &amp; Geosciences, 96, 56-68. arXiv:1606.06204</p> </li> </ul>"},{"location":"algorithm-details/fill/#core-concept","title":"Core Concept","text":"<p>The Priority-Flood algorithm processes cells in order of elevation, starting from the DEM boundary and working inward. Each cell is assigned a label identifying its watershed, and depressions are filled by raising cells to the elevation of their pour point.</p>"},{"location":"algorithm-details/fill/#data-structures","title":"Data Structures","text":"Structure Description Priority Queue Min-heap ordered by elevation, stores boundary cells Pit Queue FIFO queue for cells within depressions Labels Array Integer grid assigning each cell to a watershed Watershed Graph Adjacency structure storing spillover elevations between watersheds"},{"location":"algorithm-details/fill/#algorithm","title":"Algorithm","text":""},{"location":"algorithm-details/fill/#initialization","title":"Initialization","text":"<ol> <li>Create an empty labels array (all zeros)</li> <li>Add all boundary cells to the priority queue with their elevations</li> <li>Nodata boundary cells receive priority \\(-\\infty\\)</li> </ol>"},{"location":"algorithm-details/fill/#main-loop","title":"Main Loop","text":"<p>The algorithm maintains two queues: a priority queue (ordered by elevation) and a pit queue (FIFO). The pit queue takes precedence to ensure depressions are fully processed before moving to higher terrain.</p> <pre><code>def priority_flood(dem, labels):\n    priority_queue = MinHeap()\n    pit_queue = Queue()\n    graph = WatershedGraph()\n    next_label = 2  # Reserve 1 for edge label\n\n    # Initialize with boundary cells\n    for cell in boundary_cells(dem):\n        if is_nodata(cell):\n            priority_queue.push((-infinity, cell))\n        else:\n            priority_queue.push((dem[cell], cell))\n\n    while not priority_queue.empty() or not pit_queue.empty():\n        # Pit queue has priority\n        if not pit_queue.empty():\n            current = pit_queue.pop()\n        else:\n            current = priority_queue.pop()\n\n        # Assign label if unlabeled\n        if labels[current] == 0:\n            labels[current] = next_label\n            next_label += 1\n\n        for neighbor in neighbors_8(current):\n            if labels[neighbor] != 0:\n                # Record watershed adjacency\n                spill_elev = max(dem[current], dem[neighbor])\n                graph.add_edge(labels[current], labels[neighbor], spill_elev)\n                continue\n\n            # Assign same label to neighbor\n            labels[neighbor] = labels[current]\n\n            if dem[neighbor] &lt;= dem[current]:\n                # Neighbor is in depression - add to pit queue\n                dem[neighbor] = dem[current]  # Fill to current elevation\n                pit_queue.push(neighbor)\n            else:\n                # Neighbor is higher - add to priority queue\n                priority_queue.push((dem[neighbor], neighbor))\n\n    return labels, graph\n</code></pre>"},{"location":"algorithm-details/fill/#watershed-graph","title":"Watershed Graph","text":"<p>The watershed graph \\(G = (V, E)\\) represents connectivity between labeled regions:</p> <ul> <li>Vertices \\(V\\): Watershed labels</li> <li>Edges \\(E\\): Pairs of adjacent watersheds with spillover elevation</li> </ul> <p>For adjacent watersheds \\(w_1\\) and \\(w_2\\), the spillover elevation is:</p> \\[ z_{\\text{spill}}(w_1, w_2) = \\min_{c_1 \\in w_1, c_2 \\in w_2, c_1 \\sim c_2} \\max(z_{c_1}, z_{c_2}) \\] <p>where \\(c_1 \\sim c_2\\) denotes 8-connected adjacency.</p>"},{"location":"algorithm-details/fill/#tiled-processing","title":"Tiled Processing","text":"<p>For DEMs exceeding available memory, the algorithm uses a three-phase approach based on Barnes (2016):</p>"},{"location":"algorithm-details/fill/#phase-1-local-fill","title":"Phase 1: Local Fill","text":"<p>Process each tile independently:</p> <ol> <li>Run Priority-Flood on the tile</li> <li>Extract perimeter cells (labels and elevations)</li> <li>Build local watershed graph</li> </ol>"},{"location":"algorithm-details/fill/#phase-2-graph-connection","title":"Phase 2: Graph Connection","text":"<p>Connect tiles by examining shared boundaries:</p> <p>For adjacent tiles \\(A\\) and \\(B\\) sharing an edge, for each pair of adjacent perimeter cells \\((a, b)\\) where \\(a \\in A\\) and \\(b \\in B\\):</p> \\[ \\text{graph.add\\_edge}(\\text{label}_a, \\text{label}_b, \\max(z_a, z_b)) \\] <p>Corner connections follow the same principle for tiles sharing only a corner cell.</p>"},{"location":"algorithm-details/fill/#phase-3-graph-solving","title":"Phase 3: Graph Solving","text":"<p>Determine the minimum fill elevation for each watershed label using a modified Priority-Flood on the graph structure:</p> <pre><code>def solve_graph(graph):\n    min_elevation = {}\n    queue = MinHeap()\n\n    # Start from edge label (connected to boundary)\n    queue.push((-infinity, EDGE_LABEL))\n\n    while not queue.empty():\n        elev, label = queue.pop()\n\n        if label in min_elevation:\n            continue\n\n        min_elevation[label] = elev\n\n        for neighbor, spill_elev in graph.neighbors(label):\n            if neighbor not in min_elevation:\n                new_elev = max(elev, spill_elev)\n                queue.push((new_elev, neighbor))\n\n    return min_elevation\n</code></pre>"},{"location":"algorithm-details/fill/#phase-4-elevation-raising","title":"Phase 4: Elevation Raising","text":"<p>Apply the solved elevations to each tile:</p> \\[ z'_c = \\max(z_c, z_{\\min}(\\text{label}_c)) \\] <p>where \\(z_{\\min}(w)\\) is the minimum fill elevation for watershed \\(w\\).</p>"},{"location":"algorithm-details/fill/#nodata-handling","title":"Nodata Handling","text":"<p>Two modes are supported via the <code>fill_holes</code> parameter:</p> <p>fill_holes = False (default):</p> <ul> <li>Nodata regions act as drainage outlets</li> <li>Contiguous nodata regions receive unique labels</li> <li>Boundary nodata cells added to priority queue with \\(-\\infty\\)</li> </ul> <p>fill_holes = True:</p> <ul> <li>Nodata cells are filled with the elevation of the lowest surrounding valid cell</li> <li>Useful for DEMs with data gaps that should be interpolated</li> </ul>"},{"location":"algorithm-details/fill/#properties","title":"Properties","text":"<p>The filled DEM satisfies:</p> <ol> <li>No depressions: Every cell has a monotonically non-increasing path to the boundary</li> <li>Minimal modification: Cells are only raised, never lowered</li> <li>Elevation preservation: Cells not in depressions retain original values</li> </ol> <p>Formally, for output elevation \\(z'\\):</p> \\[ z'_c \\geq z_c \\quad \\forall c \\] \\[ \\forall c \\in \\text{interior}: \\exists n \\in N(c) : z'_n \\leq z'_c \\]"},{"location":"algorithm-details/fill/#complexity","title":"Complexity","text":"<p>Let \\(n\\) be the number of cells.</p> Operation Time Complexity Space Complexity Priority-Flood \\(O(n \\log n)\\) \\(O(n)\\) Graph solving \\(O(w \\log w)\\) \\(O(w)\\) <p>Where \\(w\\) is the number of distinct watersheds (typically \\(w \\ll n\\)).</p> <p>For tiled processing with \\(t\\) tiles of size \\(s \\times s\\):</p> <ul> <li>Per-tile: \\(O(s^2 \\log s^2)\\)</li> <li>Graph connection: \\(O(t \\cdot s)\\) (perimeter size)</li> <li>Total: \\(O(n \\log s + t \\cdot s)\\)</li> </ul>"},{"location":"algorithm-details/fill/#visual-example","title":"Visual Example","text":"Before Fill After Fill <p>The depression (highlighted in red) contains cells with elevations ranging from 94.0 to 96.8. The pour point elevation is 97.0. After filling, all depression cells are raised to the pour point elevation, ensuring water can flow out of the depression without encountering lower cells.</p>"},{"location":"algorithm-details/flat-resolution/","title":"Flat Resolution Algorithm","text":""},{"location":"algorithm-details/flat-resolution/#overview","title":"Overview","text":"<p>The flat resolution algorithm assigns flow directions to cells within flat regions (areas of constant elevation) where the standard D8 steepest-descent method cannot determine flow. It creates a synthetic gradient by combining two distance-based surfaces.</p>"},{"location":"algorithm-details/flat-resolution/#references","title":"References","text":"<p>Barnes, R., Lehman, C., Mulla, D. (2014). \"An Efficient Assignment of Drainage Direction Over Flat Surfaces in Raster Digital Elevation Models.\" Computers &amp; Geosciences, 62, 128-135. PDF</p> <p>Zhou, G., Song, L., Liu, Y. (2021). \"Parallel Assignment of Flow Directions Over Flat Surfaces in Massive Digital Elevation Models.\" Computers &amp; Geosciences, 159, 105015. DOI</p>"},{"location":"algorithm-details/flat-resolution/#core-concept","title":"Core Concept","text":"<p>The algorithm constructs a flat mask that encodes directional preference without modifying the original DEM. This mask is the superposition of two gradients:</p> <ol> <li>Away from higher terrain (\\(G_{\\text{high}}\\)): Values increase with distance from cells adjacent to higher ground</li> <li>Toward lower terrain (\\(G_{\\text{low}}\\)): Values increase with distance from cells adjacent to lower ground (drainage outlets)</li> </ol> <p>The combination directs flow away from ridges and toward natural drainage points.</p>"},{"location":"algorithm-details/flat-resolution/#definitions","title":"Definitions","text":"<p>Flat region: A connected set of cells \\(F\\) where: $$ \\forall c_1, c_2 \\in F: z_{c_1} = z_{c_2} \\text{ and } c_1 \\sim c_2 \\text{ (connected)} $$</p> <p>High edge: Cells in \\(F\\) adjacent to higher terrain $$ H = {c \\in F : \\exists n \\in N(c), n \\notin F, z_n &gt; z_c} $$</p> <p>Low edge: Cells in \\(F\\) adjacent to lower terrain or nodata $$ L = {c \\in F : \\exists n \\in N(c), z_n &lt; z_c \\text{ or } n \\text{ is nodata}} $$</p>"},{"location":"algorithm-details/flat-resolution/#algorithm-overview","title":"Algorithm Overview","text":"<p>The algorithm proceeds in four phases:</p> <ol> <li>FlatEdges: Identify high-edge and low-edge cells</li> <li>AwayFromHigher: Propagate gradient from high edges</li> <li>TowardLower: Propagate gradient from low edges and combine</li> <li>AssignDirections: Use flat mask to determine D8 directions</li> </ol>"},{"location":"algorithm-details/flat-resolution/#phase-1-identify-flat-edges","title":"Phase 1: Identify Flat Edges","text":"<p>Scan all cells with undefined flow direction (code 8) and classify as high-edge or low-edge:</p> <pre><code>def flat_edges(dem, fdr):\n    high_edges = []\n    low_edges = []\n\n    for cell in all_cells():\n        if fdr[cell] != UNDEFINED:\n            continue\n\n        for neighbor in neighbors_8(cell):\n            if dem[neighbor] &gt; dem[cell]:\n                high_edges.append(cell)\n                break\n            if dem[neighbor] &lt; dem[cell] or is_nodata(neighbor):\n                low_edges.append(cell)\n                break\n\n    return high_edges, low_edges\n</code></pre>"},{"location":"algorithm-details/flat-resolution/#phase-2-gradient-away-from-higher-terrain","title":"Phase 2: Gradient Away from Higher Terrain","text":"<p>Use breadth-first search from high-edge cells. Each cell records its distance (in \"loops\" or BFS iterations) from the nearest high edge:</p> <pre><code>def away_from_higher(flat_mask, high_edges, dem, fdr):\n    queue = Queue()\n    loops = 1\n\n    for cell in high_edges:\n        flat_mask[cell] = 1\n        queue.push(cell)\n\n    while not queue.empty():\n        loops += 1\n        size = queue.size()\n\n        for _ in range(size):\n            current = queue.pop()\n\n            for neighbor in neighbors_8(current):\n                if fdr[neighbor] != UNDEFINED:\n                    continue\n                if dem[neighbor] != dem[current]:\n                    continue\n                if flat_mask[neighbor] != 0:\n                    continue\n\n                flat_mask[neighbor] = loops\n                queue.push(neighbor)\n</code></pre> <p>After this phase: $$ G_{\\text{high}}(c) = \\text{BFS distance from } c \\text{ to nearest high edge} $$</p>"},{"location":"algorithm-details/flat-resolution/#phase-3-gradient-toward-lower-terrain","title":"Phase 3: Gradient Toward Lower Terrain","text":"<p>Propagate from low-edge cells and combine with the existing gradient. The combination formula ensures cells preferentially flow toward drainage points while avoiding high terrain:</p> <pre><code>def toward_lower(flat_mask, low_edges, dem, fdr):\n    # Negate existing values\n    for cell in all_cells():\n        if flat_mask[cell] &gt; 0:\n            flat_mask[cell] = -flat_mask[cell]\n\n    queue = Queue()\n    loops = 1\n\n    for cell in low_edges:\n        if flat_mask[cell] &lt; 0:\n            # Already visited by away_from_higher\n            flat_mask[cell] += MAX_FLAT_HEIGHT + 2 * loops\n        else:\n            flat_mask[cell] = 2 * loops\n        queue.push(cell)\n\n    while not queue.empty():\n        loops += 1\n        size = queue.size()\n\n        for _ in range(size):\n            current = queue.pop()\n\n            for neighbor in neighbors_8(current):\n                if fdr[neighbor] != UNDEFINED:\n                    continue\n                if dem[neighbor] != dem[current]:\n                    continue\n\n                if flat_mask[neighbor] &lt; 0:\n                    # Combine gradients\n                    flat_mask[neighbor] += MAX_FLAT_HEIGHT + 2 * loops\n                elif flat_mask[neighbor] == 0:\n                    flat_mask[neighbor] = 2 * loops\n\n                queue.push(neighbor)\n</code></pre>"},{"location":"algorithm-details/flat-resolution/#gradient-combination","title":"Gradient Combination","text":"<p>The final flat mask value for cell \\(c\\) combines both gradients:</p> \\[ M(c) = G_{\\text{low}}(c) \\cdot 2 + G_{\\text{high}}(c) + K \\] <p>Where: - \\(G_{\\text{low}}(c)\\) = BFS distance to nearest low edge - \\(G_{\\text{high}}(c)\\) = BFS distance to nearest high edge - \\(K\\) = constant offset to ensure positive values</p> <p>The factor of 2 on \\(G_{\\text{low}}\\) gives priority to draining toward outlets over moving away from ridges.</p>"},{"location":"algorithm-details/flat-resolution/#phase-4-assign-flow-directions","title":"Phase 4: Assign Flow Directions","text":"<p>Use the flat mask as a synthetic elevation surface. Flow direction is assigned toward the neighbor with the minimum mask value:</p> <pre><code>def assign_flat_directions(flat_mask, fdr, dem):\n    for cell in all_cells():\n        if fdr[cell] != UNDEFINED:\n            continue\n\n        min_value = infinity\n        min_direction = -1\n\n        for direction in range(8):\n            neighbor = get_neighbor(cell, direction)\n\n            if dem[neighbor] != dem[cell]:\n                if dem[neighbor] &lt; dem[cell] or is_nodata(neighbor):\n                    # Direct drainage - use immediately\n                    min_direction = direction\n                    break\n                continue\n\n            distance = sqrt(2) if is_diagonal(direction) else 1.0\n            slope = (flat_mask[cell] - flat_mask[neighbor]) / distance\n\n            if slope &gt; 0 and flat_mask[neighbor] &lt; min_value:\n                min_value = flat_mask[neighbor]\n                min_direction = direction\n\n        if min_direction &gt;= 0:\n            fdr[cell] = min_direction\n</code></pre>"},{"location":"algorithm-details/flat-resolution/#tiled-processing","title":"Tiled Processing","text":"<p>For large DEMs, the algorithm uses graph-based connectivity to solve flat regions spanning multiple tiles. The tiled implementation is based on Zhou et al. (2021), which extends the Barnes et al. (2014) algorithm to support parallel processing of massive DEMs.</p>"},{"location":"algorithm-details/flat-resolution/#local-graph-construction","title":"Local Graph Construction","text":"<p>For each tile: 1. Identify flat cells on tile perimeter 2. Compute distances between perimeter cells via BFS 3. Record connections to high/low terrain</p>"},{"location":"algorithm-details/flat-resolution/#global-graph-solving","title":"Global Graph Solving","text":"<ol> <li>Join adjacent tiles by connecting matching perimeter cells</li> <li>Solve shortest paths from all perimeter cells to high/low terrain using Dijkstra's algorithm</li> <li>Use precomputed distances when creating flat masks</li> </ol>"},{"location":"algorithm-details/flat-resolution/#distance-computation","title":"Distance Computation","text":"<p>For two perimeter cells \\(p_1\\) and \\(p_2\\) in the same flat region within a tile:</p> \\[ d(p_1, p_2) = \\text{BFS distance through flat cells} \\] <p>If no path exists through flat cells, an estimate using Chebyshev distance is used:</p> \\[ d_{\\text{Chebyshev}}(p_1, p_2) = \\max(|r_1 - r_2|, |c_1 - c_2|) \\] <p>This is valid when the path can traverse the flat region diagonally.</p>"},{"location":"algorithm-details/flat-resolution/#properties","title":"Properties","text":"<p>The resolved flat regions satisfy:</p> <ol> <li>Complete resolution: Every undefined cell receives a valid direction (0-7)</li> <li>Consistency: Flow paths within flats do not form cycles</li> <li>Natural drainage: Flow preferentially moves toward low edges</li> </ol>"},{"location":"algorithm-details/flat-resolution/#complexity","title":"Complexity","text":"<p>Let \\(n\\) be the number of cells and \\(f\\) the number of flat cells.</p> Operation Time Complexity Edge identification \\(O(f)\\) BFS propagation \\(O(f)\\) Direction assignment \\(O(f)\\) Total \\(O(f)\\) <p>For tiled processing with graph solving:</p> Operation Time Complexity Local BFS \\(O(f_t)\\) per tile Global Dijkstra \\(O(p \\log p)\\) <p>Where \\(f_t\\) is flat cells per tile and \\(p\\) is total perimeter cells.</p>"},{"location":"algorithm-details/flat-resolution/#performance-considerations","title":"Performance Considerations","text":"<p>Tiled flat resolution is the most computationally intensive process in Overflow due to:</p> <ul> <li>Potentially large flat regions spanning many tiles</li> <li>Graph construction overhead</li> <li>Global shortest-path computation</li> </ul> <p>For DEMs with large flat areas (lakes, filled depressions), smaller tile sizes (e.g., 512) are recommended.</p>"},{"location":"algorithm-details/flat-resolution/#see-also","title":"See Also","text":"<ul> <li>Flow Direction - Initial flow direction computation</li> <li>Fill - Depression filling creates flat regions requiring resolution</li> </ul>"},{"location":"algorithm-details/flow-accumulation/","title":"Flow Accumulation Algorithm","text":""},{"location":"algorithm-details/flow-accumulation/#overview","title":"Overview","text":"<p>The flow accumulation algorithm computes the upstream drainage area for each cell. The output value represents the count of cells whose flow paths traverse the cell, providing the basis for stream network extraction and watershed analysis.</p>"},{"location":"algorithm-details/flow-accumulation/#reference","title":"Reference","text":"<p>Barnes, R. (2017). \"Parallel Non-divergent Flow Accumulation For Trillion Cell Digital Elevation Models On Desktops Or Clusters.\" Environmental Modelling &amp; Software, 92, 202-212. arXiv:1608.04431</p>"},{"location":"algorithm-details/flow-accumulation/#core-concept","title":"Core Concept","text":"<p>Flow accumulation uses topological sorting to process cells in dependency order. A cell can only be processed after all cells that flow into it have been processed. This ensures correct accumulation without iteration.</p>"},{"location":"algorithm-details/flow-accumulation/#data-structures","title":"Data Structures","text":"Structure Description Inflow Count Integer grid counting upstream neighbors for each cell Accumulation Integer grid storing cumulative flow for each cell Queue FIFO queue for cells ready to process (inflow count = 0) Links For tiled processing: where perimeter cells drain to"},{"location":"algorithm-details/flow-accumulation/#algorithm","title":"Algorithm","text":""},{"location":"algorithm-details/flow-accumulation/#dependency-calculation","title":"Dependency Calculation","text":"<p>For each cell, count how many neighbors flow into it:</p> \\[ \\text{inflow}(c) = |\\{n \\in N(c) : \\text{downstream}(n) = c\\}| \\] <p>where \\(\\text{downstream}(n)\\) is the cell that \\(n\\) flows to according to the flow direction raster.</p>"},{"location":"algorithm-details/flow-accumulation/#topological-sort-processing","title":"Topological Sort Processing","text":"<pre><code>def flow_accumulation(fdr):\n    rows, cols = fdr.shape\n    accumulation = zeros((rows, cols), dtype=int64)\n    inflow_count = zeros((rows, cols), dtype=uint8)\n    queue = Queue()\n\n    # Phase 1: Calculate inflow counts\n    for cell in all_cells():\n        downstream = get_downstream(cell, fdr)\n        if downstream is not None:\n            inflow_count[downstream] += 1\n\n    # Phase 2: Initialize queue with source cells\n    for cell in all_cells():\n        if inflow_count[cell] == 0:\n            queue.push(cell)\n\n    # Phase 3: Process in topological order\n    while not queue.empty():\n        cell = queue.pop()\n\n        # Each cell contributes itself\n        accumulation[cell] += 1\n\n        # Pass accumulation to downstream cell\n        downstream = get_downstream(cell, fdr)\n        if downstream is None:\n            continue\n\n        accumulation[downstream] += accumulation[cell]\n        inflow_count[downstream] -= 1\n\n        # If downstream has no more pending inflows, it's ready\n        if inflow_count[downstream] == 0:\n            queue.push(downstream)\n\n    return accumulation\n</code></pre>"},{"location":"algorithm-details/flow-accumulation/#downstream-cell-lookup","title":"Downstream Cell Lookup","text":"<p>Given a flow direction code \\(d \\in \\{0, 1, \\ldots, 7\\}\\):</p> \\[ \\text{downstream}(r, c) = (r + \\Delta r_d, c + \\Delta c_d) \\] <p>Using the offset table from Flow Direction.</p>"},{"location":"algorithm-details/flow-accumulation/#properties","title":"Properties","text":"<p>The output accumulation raster satisfies:</p> <ol> <li>Minimum value: Every cell has accumulation \\(\\geq 1\\) (counts itself)</li> <li>Conservation: Total inflow equals total outflow for interior cells</li> <li>Monotonic increase: Accumulation increases along flow paths</li> </ol> \\[ \\text{acc}(c) = 1 + \\sum_{n : \\text{downstream}(n) = c} \\text{acc}(n) \\]"},{"location":"algorithm-details/flow-accumulation/#tiled-processing","title":"Tiled Processing","text":"<p>For large rasters, the algorithm uses a three-phase approach:</p>"},{"location":"algorithm-details/flow-accumulation/#phase-1-local-accumulation","title":"Phase 1: Local Accumulation","text":"<p>Process each tile independently:</p> <ol> <li>Run single-tile flow accumulation</li> <li>Build links for perimeter cells: where they ultimately drain within the tile</li> </ol> <pre><code>def follow_path(cell, fdr, tile_bounds):\n    \"\"\"Follow flow from perimeter cell to determine destination.\"\"\"\n    current = cell\n\n    while True:\n        downstream = get_downstream(current, fdr)\n\n        if downstream is None:\n            return FLOW_TERMINATES\n\n        if out_of_tile(downstream, tile_bounds):\n            return FLOW_EXTERNAL\n\n        if on_perimeter(downstream, tile_bounds):\n            return downstream  # Exits via another perimeter cell\n\n        current = downstream\n</code></pre>"},{"location":"algorithm-details/flow-accumulation/#phase-2-global-graph-construction","title":"Phase 2: Global Graph Construction","text":"<p>Build a graph connecting tiles via their perimeter cells:</p> <p>Vertices: Perimeter cells from all tiles Edges: Flow connections between perimeter cells</p> <p>For each perimeter cell \\(p\\): - If \\(p\\) flows external (leaves tile): create edge to corresponding cell in adjacent tile - If \\(p\\) flows to another perimeter cell \\(p'\\): create internal edge</p> <p>The global graph is then processed using the same topological sort:</p> <pre><code>def solve_global_graph(tiles, links):\n    global_acc = {}\n    global_offset = {}\n    inflow_count = {}\n    queue = Queue()\n\n    # Build dependency counts\n    for tile in tiles:\n        for perimeter_cell in tile.perimeter:\n            link = links[perimeter_cell]\n            if link != FLOW_TERMINATES:\n                inflow_count[link] += 1\n\n    # Initialize queue with sources\n    for cell in all_perimeter_cells():\n        if inflow_count[cell] == 0:\n            queue.push(cell)\n\n    # Topological processing\n    while not queue.empty():\n        cell = queue.pop()\n        # ... accumulate and propagate\n</code></pre>"},{"location":"algorithm-details/flow-accumulation/#phase-3-finalization","title":"Phase 3: Finalization","text":"<p>Apply global offsets to each tile:</p> <p>For perimeter cell \\(p\\) with global offset \\(\\delta_p\\), follow the flow path within the tile and add \\(\\delta_p\\) to all cells along the path:</p> <pre><code>def finalize_tile(tile, global_offset, links):\n    for perimeter_cell in tile.perimeter:\n        if perimeter_cell in global_offset:\n            offset = global_offset[perimeter_cell]\n            current = perimeter_cell\n\n            while current is not None:\n                tile.accumulation[current] += offset\n                downstream = get_downstream(current)\n\n                # Stop if we hit another global node\n                if downstream in global_acc:\n                    break\n\n                current = downstream\n</code></pre>"},{"location":"algorithm-details/flow-accumulation/#perimeter-structure","title":"Perimeter Structure","text":"<p>Tile perimeters are stored as 1D arrays in clockwise order:</p> <pre><code>Top edge (left to right)\n  -&gt; Right edge (top to bottom)\n    -&gt; Bottom edge (right to left)\n      -&gt; Left edge (bottom to top)\n</code></pre> <p>Total perimeter size: \\(2(w + h) - 4\\) cells for a \\(w \\times h\\) tile.</p>"},{"location":"algorithm-details/flow-accumulation/#global-coordinate-mapping","title":"Global Coordinate Mapping","text":"<p>For a tile at grid position \\((t_r, t_c)\\) with chunk size \\(s\\):</p> \\[ \\text{global\\_index}(r, c) = (t_r \\cdot s + r) \\cdot (n_c \\cdot s) + (t_c \\cdot s + c) \\] <p>This provides a unique identifier for inter-tile graph construction.</p>"},{"location":"algorithm-details/flow-accumulation/#complexity","title":"Complexity","text":"<p>Let \\(n\\) be the total number of cells.</p> <p>Single-tile processing:</p> Operation Time Space Inflow counting \\(O(n)\\) \\(O(n)\\) Queue processing \\(O(n)\\) \\(O(n)\\) Total \\(O(n)\\) \\(O(n)\\) <p>Tiled processing with \\(t\\) tiles of size \\(s \\times s\\):</p> Operation Time Space Local accumulation \\(O(s^2)\\) per tile \\(O(s^2)\\) Graph construction \\(O(p)\\) \\(O(p)\\) Graph solving \\(O(p)\\) \\(O(p)\\) Finalization \\(O(s^2)\\) per tile \\(O(1)\\) <p>Where \\(p = O(t \\cdot s)\\) is the total perimeter cells.</p>"},{"location":"algorithm-details/flow-accumulation/#input-requirements","title":"Input Requirements","text":"<p>The flow direction raster must satisfy:</p> <ol> <li>No undefined cells: All non-nodata cells have direction 0-7</li> <li>Acyclic: No cycles in the flow graph</li> </ol> <p>These requirements are automatically met when using <code>flow_direction()</code> with <code>resolve_flats=True</code> on a properly conditioned (filled) DEM.</p>"},{"location":"algorithm-details/flow-accumulation/#see-also","title":"See Also","text":"<ul> <li>Flow Direction - Computing flow directions</li> <li>Stream Extraction - Using accumulation to extract streams</li> <li>Basin Delineation - Watershed analysis</li> </ul>"},{"location":"algorithm-details/flow-direction/","title":"Flow Direction Algorithm","text":""},{"location":"algorithm-details/flow-direction/#overview","title":"Overview","text":"<p>The flow direction algorithm assigns each cell a D8 direction code indicating the steepest descent to one of eight neighbors. This is the foundational step for all downstream hydrological analysis.</p>"},{"location":"algorithm-details/flow-direction/#d8-flow-model","title":"D8 Flow Model","text":"<p>The D8 (deterministic eight-neighbor) model directs all flow from a cell to the single neighbor with the steepest downhill slope. Each cell receives exactly one flow direction.</p>"},{"location":"algorithm-details/flow-direction/#direction-encoding","title":"Direction Encoding","text":"<p>Directions are encoded as integers 0-9:</p> Code Direction Offset \\((\\Delta c, \\Delta r)\\) 0 East \\((1, 0)\\) 1 Northeast \\((1, -1)\\) 2 North \\((0, -1)\\) 3 Northwest \\((-1, -1)\\) 4 West \\((-1, 0)\\) 5 Southwest \\((-1, 1)\\) 6 South \\((0, 1)\\) 7 Southeast \\((1, 1)\\) 8 Undefined \u2014 9 Nodata \u2014 <p>Direction indices proceed counter-clockwise from East.</p>"},{"location":"algorithm-details/flow-direction/#visual-representation","title":"Visual Representation","text":"<pre><code>  3  |  2  |  1\n-----+-----+-----\n  4  |  X  |  0\n-----+-----+-----\n  5  |  6  |  7\n</code></pre>"},{"location":"algorithm-details/flow-direction/#slope-calculation","title":"Slope Calculation","text":"<p>For a cell \\(c\\) at position \\((r, c)\\) with elevation \\(z_c\\), the slope to neighbor \\(n\\) at position \\((r + \\Delta r, c + \\Delta c)\\) is:</p> \\[ S_{c \\to n} = \\frac{z_c - z_n}{d_{c,n}} \\] <p>where \\(d_{c,n}\\) is the distance between cell centers:</p> \\[ d_{c,n} = \\begin{cases} 1 &amp; \\text{cardinal directions (N, S, E, W)} \\\\ \\sqrt{2} &amp; \\text{diagonal directions (NE, NW, SE, SW)} \\end{cases} \\] <p>The distance normalization ensures that diagonal and cardinal flows are weighted appropriately. Without it, diagonal neighbors would be unfairly penalized due to their greater physical distance.</p>"},{"location":"algorithm-details/flow-direction/#algorithm","title":"Algorithm","text":"<p>For each cell, compute slopes to all valid neighbors and select the steepest descent:</p> <pre><code>def flow_direction(dem, nodata):\n    rows, cols = dem.shape\n    fdr = empty((rows, cols), dtype=uint8)\n\n    for row in range(rows):\n        for col in range(cols):\n            if is_nodata(dem[row, col]) or is_nan(dem[row, col]):\n                fdr[row, col] = 9  # Nodata\n                continue\n\n            max_slope = -infinity\n            max_direction = -1\n\n            for direction in range(8):\n                dr, dc = OFFSETS[direction]\n                nr, nc = row + dr, col + dc\n\n                if out_of_bounds(nr, nc):\n                    continue\n\n                if is_nodata(dem[nr, nc]) or is_nan(dem[nr, nc]):\n                    continue\n\n                distance = sqrt(2) if is_diagonal(direction) else 1.0\n                slope = (dem[row, col] - dem[nr, nc]) / distance\n\n                if slope &gt; max_slope:\n                    max_slope = slope\n                    max_direction = direction\n\n            if max_slope &lt;= 0:\n                fdr[row, col] = 8  # Undefined (flat or pit)\n            else:\n                fdr[row, col] = max_direction\n\n    return fdr\n</code></pre>"},{"location":"algorithm-details/flow-direction/#flat-regions-and-undefined-flow","title":"Flat Regions and Undefined Flow","text":"<p>When all neighbors have elevation \\(\\geq z_c\\) (local minimum or flat), no valid downhill direction exists. These cells receive code 8 (undefined).</p> <p>Flat region: All neighbors have equal elevation $$ \\forall n \\in N(c): z_n = z_c \\implies \\text{fdr}_c = 8 $$</p> <p>Pit/sink: All neighbors have greater elevation $$ \\forall n \\in N(c): z_n &gt; z_c \\implies \\text{fdr}_c = 8 $$</p> <p>To resolve undefined flow in flat regions, apply the Flat Resolution algorithm.</p>"},{"location":"algorithm-details/flow-direction/#nodata-handling","title":"Nodata Handling","text":"<ul> <li>Input nodata: Cells with nodata elevation receive direction code 9</li> <li>Nodata neighbors: Excluded from slope calculation (flow cannot enter nodata)</li> <li>Propagation: Nodata status propagates to flow direction output</li> </ul>"},{"location":"algorithm-details/flow-direction/#properties","title":"Properties","text":"<p>The D8 flow direction raster satisfies:</p> <ol> <li>Deterministic: Each cell has exactly one flow direction</li> <li>Unique outflow: Water from any cell flows to exactly one neighbor</li> <li>Acyclic (on conditioned DEMs): Following flow directions never returns to the starting cell</li> </ol> <p>Formally, for a properly conditioned DEM:</p> \\[ \\text{fdr}_c \\in \\{0, 1, \\ldots, 7\\} \\implies z_{\\text{downstream}(c)} &lt; z_c \\]"},{"location":"algorithm-details/flow-direction/#chunked-processing","title":"Chunked Processing","text":"<p>For large rasters, processing is performed in tiles with a 1-pixel buffer:</p> <ol> <li>Read tile with 1-pixel overlap on all edges</li> <li>Compute flow directions for interior cells</li> <li>Buffer ensures all 8 neighbors are available for interior cells</li> <li>Write interior (non-buffer) region to output</li> </ol>"},{"location":"algorithm-details/flow-direction/#complexity","title":"Complexity","text":"Metric Value Time \\(O(n)\\) Space \\(O(n)\\) Per-cell operations 8 neighbor comparisons <p>Where \\(n\\) is the number of cells.</p>"},{"location":"algorithm-details/flow-direction/#limitations","title":"Limitations","text":"<ol> <li>Flat regions: Cannot resolve flow in areas of constant elevation without additional processing</li> <li>Single flow path: Does not support flow dispersion (unlike D-infinity or multiple flow direction models)</li> <li>Grid artifact sensitivity: Results depend on DEM resolution and alignment</li> </ol>"},{"location":"algorithm-details/flow-direction/#see-also","title":"See Also","text":"<ul> <li>Flat Resolution - Resolving undefined flow directions</li> <li>Fill - Depression removal before flow direction</li> <li>Flow Accumulation - Computing drainage area from flow directions</li> </ul>"},{"location":"algorithm-details/flow-length/","title":"Flow Length Algorithm","text":""},{"location":"algorithm-details/flow-length/#overview","title":"Overview","text":"<p>The flow length algorithm computes the longest upstream flow path distance for each cell. This metric is used in hydrological modeling to estimate time of concentration, characterize watershed shape, and identify the hydraulically most distant point.</p>"},{"location":"algorithm-details/flow-length/#core-concept","title":"Core Concept","text":"<p>The algorithm uses multi-basin upstream BFS to propagate distance values from drainage points (outlets) through the flow network. Each cell records the maximum distance from the outlet along any upstream path.</p>"},{"location":"algorithm-details/flow-length/#definitions","title":"Definitions","text":"<p>Flow length: The distance along the flow path from a cell to its basin outlet:</p> \\[ L(c) = \\sum_{i=0}^{k-1} d(p_i, p_{i+1}) \\] <p>where \\(P = [p_0 = c, p_1, \\ldots, p_k = \\text{outlet}]\\) is the flow path and \\(d(p_i, p_{i+1})\\) is the step distance.</p> <p>Longest flow path: The path from outlet to the hydraulically most distant cell in the basin.</p>"},{"location":"algorithm-details/flow-length/#distance-calculation","title":"Distance Calculation","text":""},{"location":"algorithm-details/flow-length/#projected-coordinates","title":"Projected Coordinates","text":"<p>For rasters in a projected coordinate system (e.g., UTM), use Euclidean distance:</p> \\[ d(c_1, c_2) = \\sqrt{(\\Delta c \\cdot \\delta_x)^2 + (\\Delta r \\cdot \\delta_y)^2} \\] <p>where \\(\\delta_x\\) and \\(\\delta_y\\) are pixel dimensions in map units.</p> <p>For D8 flow (single-cell steps):</p> \\[ d_{\\text{step}} = \\begin{cases} \\delta_x &amp; \\text{horizontal step} \\\\ \\delta_y &amp; \\text{vertical step} \\\\ \\sqrt{\\delta_x^2 + \\delta_y^2} &amp; \\text{diagonal step} \\end{cases} \\]"},{"location":"algorithm-details/flow-length/#geographic-coordinates","title":"Geographic Coordinates","text":"<p>For rasters in geographic coordinates (latitude/longitude), use the Haversine formula:</p> \\[ d(c_1, c_2) = 2R \\arcsin\\left(\\sqrt{\\sin^2\\left(\\frac{\\Delta\\phi}{2}\\right) + \\cos\\phi_1 \\cos\\phi_2 \\sin^2\\left(\\frac{\\Delta\\lambda}{2}\\right)}\\right) \\] <p>where: - \\(R\\) = Earth's radius (approximately 6,378,137 m) - \\(\\phi_1, \\phi_2\\) = latitudes in radians - \\(\\lambda_1, \\lambda_2\\) = longitudes in radians - \\(\\Delta\\phi = \\phi_2 - \\phi_1\\) - \\(\\Delta\\lambda = \\lambda_2 - \\lambda_1\\)</p>"},{"location":"algorithm-details/flow-length/#coordinate-conversion","title":"Coordinate Conversion","text":"<p>Convert cell indices to geographic coordinates:</p> \\[ \\lambda = \\lambda_0 + (c + 0.5) \\cdot \\Delta\\lambda \\] \\[ \\phi = \\phi_0 + (r + 0.5) \\cdot \\Delta\\phi \\] <p>where \\((\\lambda_0, \\phi_0)\\) is the origin and \\((\\Delta\\lambda, \\Delta\\phi)\\) are pixel dimensions in degrees.</p>"},{"location":"algorithm-details/flow-length/#algorithm","title":"Algorithm","text":""},{"location":"algorithm-details/flow-length/#phase-1-initialize-drainage-points","title":"Phase 1: Initialize Drainage Points","text":"<p>Pre-claim drainage point cells to prevent a race condition in parallel processing:</p> <pre><code>def initialize_drainage_points(drainage_points, flow_length, basin_labels):\n    for (row, col), basin_id in drainage_points.items():\n        flow_length[row, col] = 0.0\n        basin_labels[row, col] = basin_id\n</code></pre>"},{"location":"algorithm-details/flow-length/#phase-2-upstream-bfs","title":"Phase 2: Upstream BFS","text":"<p>For each drainage point, propagate upstream using BFS:</p> <pre><code>def compute_flow_length(fdr, drainage_points, is_geographic):\n    flow_length = full(fdr.shape, -1.0)  # -1 = unvisited\n    basin_labels = zeros(fdr.shape, dtype=int64)\n    max_cells = {}  # basin_id -&gt; (row, col, max_distance)\n\n    # Initialize\n    initialize_drainage_points(drainage_points, flow_length, basin_labels)\n\n    # Process each drainage point\n    for (start_row, start_col), basin_id in drainage_points.items():\n        queue = Queue()\n        queue.push((start_row, start_col))\n        max_dist = 0.0\n        max_row, max_col = start_row, start_col\n\n        while not queue.empty():\n            row, col = queue.pop()\n            current_dist = flow_length[row, col]\n\n            for neighbor in upstream_neighbors((row, col), fdr):\n                step_dist = calculate_distance(\n                    (row, col), neighbor, is_geographic\n                )\n                new_dist = current_dist + step_dist\n\n                if basin_labels[neighbor] == 0:\n                    # Unclaimed cell - claim it\n                    basin_labels[neighbor] = basin_id\n                    flow_length[neighbor] = new_dist\n                    queue.push(neighbor)\n\n                    if new_dist &gt; max_dist:\n                        max_dist = new_dist\n                        max_row, max_col = neighbor\n\n                elif basin_labels[neighbor] == basin_id:\n                    # Same basin - update if longer path found\n                    if new_dist &gt; flow_length[neighbor]:\n                        flow_length[neighbor] = new_dist\n                        queue.push(neighbor)\n\n                        if new_dist &gt; max_dist:\n                            max_dist = new_dist\n                            max_row, max_col = neighbor\n\n        max_cells[basin_id] = (max_row, max_col, max_dist)\n\n    return flow_length, basin_labels, max_cells\n</code></pre>"},{"location":"algorithm-details/flow-length/#longest-flow-path-extraction","title":"Longest Flow Path Extraction","text":""},{"location":"algorithm-details/flow-length/#basin-graph-construction","title":"Basin Graph Construction","text":"<p>Build a graph of upstream basin relationships:</p> <pre><code>def build_basin_graph(drainage_points, fdr, basin_labels):\n    graph = {}  # basin_id -&gt; [upstream_basin_ids]\n\n    for (row, col), basin_id in drainage_points.items():\n        downstream = get_downstream((row, col), fdr)\n\n        if downstream is not None:\n            downstream_basin = basin_labels[downstream]\n            if downstream_basin != basin_id:\n                if downstream_basin not in graph:\n                    graph[downstream_basin] = []\n                graph[downstream_basin].append(basin_id)\n\n    return graph\n</code></pre>"},{"location":"algorithm-details/flow-length/#path-tracing","title":"Path Tracing","text":"<p>For a given outlet, find all upstream basins and select the one with the longest flow path:</p> <pre><code>def find_longest_flow_path(outlet_basin, graph, max_cells, fdr):\n    # Find all upstream basins\n    upstream_basins = find_all_upstream(outlet_basin, graph)\n\n    # Find basin with maximum distance\n    best_basin = outlet_basin\n    best_distance = max_cells[outlet_basin][2]\n\n    for basin_id in upstream_basins:\n        if max_cells[basin_id][2] &gt; best_distance:\n            best_distance = max_cells[basin_id][2]\n            best_basin = basin_id\n\n    # Trace path from max cell to outlet\n    max_row, max_col, _ = max_cells[best_basin]\n    path = trace_downstream((max_row, max_col), fdr, outlet_cell)\n\n    return path, best_distance\n</code></pre>"},{"location":"algorithm-details/flow-length/#upstream-basin-discovery","title":"Upstream Basin Discovery","text":"<p>Use BFS on the basin graph to find all upstream basins:</p> <pre><code>def find_all_upstream(outlet_basin, graph):\n    visited = set()\n    queue = Queue()\n    queue.push(outlet_basin)\n\n    while not queue.empty():\n        basin = queue.pop()\n\n        if basin in visited:\n            continue\n\n        visited.add(basin)\n\n        if basin in graph:\n            for upstream_basin in graph[basin]:\n                queue.push(upstream_basin)\n\n    return visited\n</code></pre>"},{"location":"algorithm-details/flow-length/#downstream-path-tracing","title":"Downstream Path Tracing","text":"<p>Trace the flow path from a cell to the outlet:</p> <pre><code>def trace_downstream(start, fdr, outlet):\n    path = [start]\n    current = start\n\n    while current != outlet:\n        downstream = get_downstream(current, fdr)\n        if downstream is None:\n            break\n        path.append(downstream)\n        current = downstream\n\n    return path\n</code></pre>"},{"location":"algorithm-details/flow-length/#output","title":"Output","text":""},{"location":"algorithm-details/flow-length/#flow-length-raster","title":"Flow Length Raster","text":"<p>A floating-point raster where each cell contains its flow distance to the outlet:</p> <ul> <li>Units: Map units (meters for projected, meters for geographic via Haversine)</li> <li>Nodata: -1 for cells not draining to any drainage point</li> </ul>"},{"location":"algorithm-details/flow-length/#longest-flow-path-vectors","title":"Longest Flow Path Vectors","text":"<p>LineString features representing the longest flow path for each basin:</p> <ul> <li>Geometry: Path from hydraulically most distant cell to outlet</li> <li>Attributes: Basin ID, path length</li> </ul>"},{"location":"algorithm-details/flow-length/#properties","title":"Properties","text":"<p>The flow length raster satisfies:</p> <ol> <li>Monotonic increase: Flow length increases upstream</li> </ol> \\[ L(\\text{upstream}(c)) &gt; L(c) \\] <ol> <li>Zero at outlets: Drainage points have flow length 0</li> </ol> \\[ L(d) = 0 \\quad \\forall d \\in D \\] <ol> <li>Path additivity: Flow length equals sum of step distances</li> </ol> \\[ L(c) = L(\\text{downstream}(c)) + d(c, \\text{downstream}(c)) \\]"},{"location":"algorithm-details/flow-length/#complexity","title":"Complexity","text":"<p>Let \\(n\\) be total cells and \\(b\\) be basin count.</p> Operation Time Complexity Upstream BFS \\(O(n)\\) Graph construction \\(O(b)\\) Upstream basin search \\(O(b)\\) Path tracing \\(O(l)\\) <p>Where \\(l\\) is the length of the longest flow path.</p>"},{"location":"algorithm-details/flow-length/#coordinate-system-detection","title":"Coordinate System Detection","text":"<p>The algorithm automatically detects whether the raster uses projected or geographic coordinates by examining the spatial reference:</p> <ul> <li>Geographic: Units are degrees, use Haversine distance</li> <li>Projected: Units are linear (meters, feet), use Euclidean distance</li> </ul>"},{"location":"algorithm-details/flow-length/#see-also","title":"See Also","text":"<ul> <li>Basin Delineation - Defining drainage basins</li> <li>Flow Direction - Computing flow directions</li> <li>Flow Accumulation - Computing drainage area</li> </ul>"},{"location":"algorithm-details/stream-extraction/","title":"Stream Extraction Algorithm","text":""},{"location":"algorithm-details/stream-extraction/#overview","title":"Overview","text":"<p>The stream extraction algorithm converts flow accumulation data into vector stream networks. Cells exceeding a threshold are classified as streams, then vectorized into polylines with junction points at confluences and sources.</p>"},{"location":"algorithm-details/stream-extraction/#core-concept","title":"Core Concept","text":"<p>Stream extraction is a three-step process:</p> <ol> <li>Classification: Apply threshold to identify stream cells</li> <li>Node Detection: Find topologically significant points (sources, confluences)</li> <li>Vectorization: Trace stream segments between nodes</li> </ol>"},{"location":"algorithm-details/stream-extraction/#stream-classification","title":"Stream Classification","text":"<p>A cell belongs to the stream network if its flow accumulation meets or exceeds the threshold:</p> \\[ \\text{is\\_stream}(c) = \\begin{cases} \\text{true} &amp; \\text{if } \\text{acc}(c) \\geq T \\\\ \\text{false} &amp; \\text{otherwise} \\end{cases} \\] <p>where \\(T\\) is the accumulation threshold parameter.</p> <p>Threshold selection:</p> <ul> <li>Lower thresholds extract more tributaries (denser network)</li> <li>Higher thresholds extract only main channels (sparser network)</li> <li>Common heuristics: \\(T = 100\\) to \\(T = 1000\\) cells, or based on contributing area</li> </ul>"},{"location":"algorithm-details/stream-extraction/#node-detection","title":"Node Detection","text":"<p>Nodes are topologically significant points in the stream network:</p> <p>Source nodes: Stream cells with no upstream stream neighbors</p> \\[ \\text{is\\_source}(c) = \\text{is\\_stream}(c) \\land |\\{n \\in N(c) : \\text{upstream}(n, c) \\land \\text{is\\_stream}(n)\\}| = 0 \\] <p>Confluence nodes: Stream cells with multiple upstream stream neighbors</p> \\[ \\text{is\\_confluence}(c) = \\text{is\\_stream}(c) \\land |\\{n \\in N(c) : \\text{upstream}(n, c) \\land \\text{is\\_stream}(n)\\}| &gt; 1 \\] <p>where \\(\\text{upstream}(n, c)\\) is true if cell \\(n\\) flows directly to cell \\(c\\).</p>"},{"location":"algorithm-details/stream-extraction/#upstream-neighbor-detection","title":"Upstream Neighbor Detection","text":"<p>A neighbor \\(n\\) is upstream of cell \\(c\\) if \\(n\\)'s flow direction points to \\(c\\):</p> <pre><code>def is_upstream(neighbor, cell, fdr):\n    \"\"\"Check if neighbor flows into cell.\"\"\"\n    downstream_of_neighbor = get_downstream(neighbor, fdr)\n    return downstream_of_neighbor == cell\n</code></pre>"},{"location":"algorithm-details/stream-extraction/#algorithm","title":"Algorithm","text":"<pre><code>def find_nodes(stream_raster, fdr):\n    nodes = []\n\n    for cell in all_cells():\n        if not stream_raster[cell]:\n            continue\n\n        # Count upstream stream neighbors\n        upstream_count = 0\n        for neighbor in neighbors_8(cell):\n            if stream_raster[neighbor] and is_upstream(neighbor, cell, fdr):\n                upstream_count += 1\n\n        if upstream_count == 0:  # Source\n            nodes.append(cell)\n        elif upstream_count &gt; 1:  # Confluence\n            nodes.append(cell)\n\n    return nodes\n</code></pre>"},{"location":"algorithm-details/stream-extraction/#stream-tracing","title":"Stream Tracing","text":"<p>Each stream segment connects two nodes. Starting from each node, trace downstream until reaching another node or the domain boundary:</p> <pre><code>def trace_stream(start_node, fdr, stream_raster, node_set):\n    path = [start_node]\n    current = start_node\n\n    while True:\n        downstream = get_downstream(current, fdr)\n\n        if downstream is None:\n            # Reached boundary\n            break\n\n        if not stream_raster[downstream]:\n            # Left stream network\n            break\n\n        path.append(downstream)\n\n        if downstream in node_set and downstream != start_node:\n            # Reached another node\n            break\n\n        current = downstream\n\n    return path\n</code></pre>"},{"location":"algorithm-details/stream-extraction/#coordinate-conversion","title":"Coordinate Conversion","text":"<p>Raster cell indices are converted to geographic coordinates using the geotransform:</p> \\[ x = x_0 + (c + 0.5) \\cdot \\Delta x \\] \\[ y = y_0 + (r + 0.5) \\cdot \\Delta y \\] <p>where: - \\((x_0, y_0)\\) is the origin (top-left corner) - \\((\\Delta x, \\Delta y)\\) are pixel dimensions - \\((r, c)\\) are row and column indices - The \\(+0.5\\) offset places coordinates at cell centers</p>"},{"location":"algorithm-details/stream-extraction/#output-structure","title":"Output Structure","text":"<p>The algorithm produces two vector layers:</p>"},{"location":"algorithm-details/stream-extraction/#streams-layer-linestring","title":"Streams Layer (LineString)","text":"<p>Each feature represents a stream segment between nodes:</p> <ul> <li>Geometry: LineString with vertices at cell centers</li> <li>Attributes: Feature ID, optional length</li> </ul>"},{"location":"algorithm-details/stream-extraction/#junctions-layer-point","title":"Junctions Layer (Point)","text":"<p>Each feature represents a topologically significant point:</p> <ul> <li>Sources: Headwater points (upstream extent)</li> <li>Confluences: Where tributaries join</li> <li>Outlets: Where streams exit the domain</li> </ul>"},{"location":"algorithm-details/stream-extraction/#tiled-processing","title":"Tiled Processing","text":"<p>For large rasters, streams are extracted per-tile and then merged:</p>"},{"location":"algorithm-details/stream-extraction/#per-tile-extraction","title":"Per-Tile Extraction","text":"<ol> <li>Extract streams and junctions within tile</li> <li>Track tile coordinates for global positioning</li> <li>Record stream endpoints for cross-tile merging</li> </ol>"},{"location":"algorithm-details/stream-extraction/#cross-tile-merging","title":"Cross-Tile Merging","text":"<p>When streams cross tile boundaries, they are split into separate features. Post-processing merges these:</p> <ol> <li>Identify edge junctions: Junctions with exactly 2 stream endpoints</li> <li>Classify merge type: Determine endpoint orientations</li> <li>Merge geometries: Concatenate coordinates in correct order</li> </ol>"},{"location":"algorithm-details/stream-extraction/#merge-types","title":"Merge Types","text":"<p>For two stream segments meeting at a junction:</p> Type Description Action 0 downstream \\(\\to\\) upstream Append second to first 1 upstream \\(\\to\\) downstream Prepend second to first 2 upstream \\(\\gets\\) upstream Reverse one, concatenate 3 downstream \\(\\gets\\) downstream Reverse one, concatenate <pre><code>def merge_streams(stream1, stream2, merge_type):\n    if merge_type == 0:\n        return stream1.coords + stream2.coords[1:]\n    elif merge_type == 1:\n        return stream2.coords + stream1.coords[1:]\n    elif merge_type == 2:\n        return list(reversed(stream1.coords)) + stream2.coords[1:]\n    elif merge_type == 3:\n        return stream1.coords + list(reversed(stream2.coords))[1:]\n</code></pre>"},{"location":"algorithm-details/stream-extraction/#spatial-hashing","title":"Spatial Hashing","text":"<p>To efficiently find matching endpoints across tiles, a spatial hash is used:</p> \\[ h(x, y) = \\lfloor x / \\delta \\rfloor \\cdot P + \\lfloor y / \\delta \\rfloor \\] <p>where \\(\\delta\\) is the grid cell size and \\(P\\) is a large prime.</p>"},{"location":"algorithm-details/stream-extraction/#complexity","title":"Complexity","text":"<p>Let \\(n\\) be total cells, \\(s\\) be stream cells, and \\(j\\) be junction count.</p> Operation Time Complexity Classification \\(O(n)\\) Node detection \\(O(s)\\) Stream tracing \\(O(s)\\) Coordinate conversion \\(O(s)\\) Total \\(O(n)\\) <p>For tiled processing with merging:</p> Operation Time Complexity Per-tile extraction \\(O(n)\\) total Edge junction finding \\(O(j)\\) Stream merging \\(O(j \\cdot l)\\) <p>where \\(l\\) is average stream segment length.</p>"},{"location":"algorithm-details/stream-extraction/#network-properties","title":"Network Properties","text":"<p>The extracted stream network forms a directed tree (or forest):</p> <ol> <li>Connectivity: All stream cells are connected</li> <li>Hierarchy: Flow direction defines parent-child relationships</li> <li>Single outlet: Each connected component has one outlet (unless truncated by boundary)</li> </ol>"},{"location":"algorithm-details/stream-extraction/#see-also","title":"See Also","text":"<ul> <li>Flow Accumulation - Computing accumulation for thresholding</li> <li>Basin Delineation - Using stream junctions as drainage points</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This reference documents the Python API for the <code>overflow</code> library.</p>"},{"location":"api/#core-functions","title":"Core Functions","text":""},{"location":"api/#overflow.breach","title":"overflow.breach","text":"<pre><code>breach(input_path, output_path, chunk_size=DEFAULT_CHUNK_SIZE, search_radius=DEFAULT_SEARCH_RADIUS, max_cost=float('inf'), progress_callback=None)\n</code></pre> <p>Breach pits in a DEM using least-cost paths.</p> <p>This function identifies pits (local minima) in the DEM and creates breach paths to allow water to flow out, minimizing the total elevation change.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str</code> <p>Path to the input DEM raster file.</p> required <code>output_path</code> <code>str</code> <p>Path for the output breached DEM raster file.</p> required <code>chunk_size</code> <code>int</code> <p>Size of processing chunks in pixels. Default is 2048.</p> <code>DEFAULT_CHUNK_SIZE</code> <code>search_radius</code> <code>int</code> <p>Maximum search radius for finding breach paths in cells. Default is 50.</p> <code>DEFAULT_SEARCH_RADIUS</code> <code>max_cost</code> <code>float</code> <p>Maximum allowed cost (total elevation change) for breach paths. Default is infinity (no limit).</p> <code>float('inf')</code> <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional callback function for progress reporting. Receives a float value between 0 and 1.</p> <code>None</code> Source code in <code>src/overflow/__init__.py</code> <pre><code>def breach(\n    input_path: str,\n    output_path: str,\n    chunk_size: int = DEFAULT_CHUNK_SIZE,\n    search_radius: int = DEFAULT_SEARCH_RADIUS,\n    max_cost: float = float(\"inf\"),\n    progress_callback: ProgressCallback | None = None,\n) -&gt; None:\n    \"\"\"\n    Breach pits in a DEM using least-cost paths.\n\n    This function identifies pits (local minima) in the DEM and creates breach\n    paths to allow water to flow out, minimizing the total elevation change.\n\n    Args:\n        input_path: Path to the input DEM raster file.\n        output_path: Path for the output breached DEM raster file.\n        chunk_size: Size of processing chunks in pixels. Default is 2048.\n        search_radius: Maximum search radius for finding breach paths in cells.\n            Default is 50.\n        max_cost: Maximum allowed cost (total elevation change) for breach paths.\n            Default is infinity (no limit).\n        progress_callback: Optional callback function for progress reporting.\n            Receives a float value between 0 and 1.\n    \"\"\"\n    _breach_paths_least_cost(\n        input_path, output_path, chunk_size, search_radius, max_cost, progress_callback\n    )\n</code></pre>"},{"location":"api/#overflow.fill","title":"overflow.fill","text":"<pre><code>fill(input_path, output_path=None, chunk_size=DEFAULT_CHUNK_SIZE, working_dir=None, fill_holes=False, progress_callback=None)\n</code></pre> <p>Fill depressions in a DEM using priority flood algorithm.</p> <p>This function fills local depressions (sinks) in the DEM to create a hydrologically conditioned surface where water can flow to the edges.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str</code> <p>Path to the input DEM raster file.</p> required <code>output_path</code> <code>str | None</code> <p>Path for the output filled DEM raster file. If None, the input file is modified in place.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>Size of processing chunks in pixels. Use chunk_size &lt;= 1 for in-memory processing (suitable for smaller DEMs). Default is 2048.</p> <code>DEFAULT_CHUNK_SIZE</code> <code>working_dir</code> <code>str | None</code> <p>Directory for temporary files during tiled processing. If None, uses system temp directory.</p> <code>None</code> <code>fill_holes</code> <code>bool</code> <p>If True, also fills holes (nodata regions) in the DEM.</p> <code>False</code> <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional callback function for progress reporting. Receives a float value between 0 and 1.</p> <code>None</code> Source code in <code>src/overflow/__init__.py</code> <pre><code>def fill(\n    input_path: str,\n    output_path: str | None = None,\n    chunk_size: int = DEFAULT_CHUNK_SIZE,\n    working_dir: str | None = None,\n    fill_holes: bool = False,\n    progress_callback: ProgressCallback | None = None,\n) -&gt; None:\n    \"\"\"\n    Fill depressions in a DEM using priority flood algorithm.\n\n    This function fills local depressions (sinks) in the DEM to create a\n    hydrologically conditioned surface where water can flow to the edges.\n\n    Args:\n        input_path: Path to the input DEM raster file.\n        output_path: Path for the output filled DEM raster file.\n            If None, the input file is modified in place.\n        chunk_size: Size of processing chunks in pixels. Use chunk_size &lt;= 1 for\n            in-memory processing (suitable for smaller DEMs). Default is 2048.\n        working_dir: Directory for temporary files during tiled processing.\n            If None, uses system temp directory.\n        fill_holes: If True, also fills holes (nodata regions) in the DEM.\n        progress_callback: Optional callback function for progress reporting.\n            Receives a float value between 0 and 1.\n    \"\"\"\n    if chunk_size &lt;= 1:\n        _fill_depressions(input_path, output_path, fill_holes)\n    else:\n        _fill_depressions_tiled(\n            input_path,\n            output_path,\n            chunk_size,\n            working_dir,\n            fill_holes,\n            progress_callback,\n        )\n</code></pre>"},{"location":"api/#overflow.flow_direction","title":"overflow.flow_direction","text":"<pre><code>flow_direction(input_path, output_path, chunk_size=DEFAULT_CHUNK_SIZE, working_dir=None, resolve_flats=True, progress_callback=None, flat_resolution_chunk_size_max=512)\n</code></pre> <p>Compute D8 flow directions from a DEM and optionally resolve flat areas.</p> <p>This function calculates the steepest descent direction for each cell using the D8 algorithm, then optionally resolves flat areas to ensure continuous flow paths.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str</code> <p>Path to the input DEM raster file (should be hydrologically conditioned, e.g., filled or breached).</p> required <code>output_path</code> <code>str</code> <p>Path for the output flow direction raster file.</p> required <code>chunk_size</code> <code>int</code> <p>Size of processing chunks in pixels. Use chunk_size &lt;= 1 for in-memory processing. Default is 2048.</p> <code>DEFAULT_CHUNK_SIZE</code> <code>working_dir</code> <code>str | None</code> <p>Directory for temporary files during tiled processing. If None, uses system temp directory.</p> <code>None</code> <code>resolve_flats</code> <code>bool</code> <p>If True (default), resolve flat areas in the flow direction raster to ensure water flows toward lower terrain.</p> <code>True</code> <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional callback function for progress reporting. Receives a float value between 0 and 1.</p> <code>None</code> <code>flat_resolution_chunk_size_max</code> <code>int</code> <p>Maximum chunk size for flat resolution processing. Default is 512. This caps the chunk size used during flat resolution to prevent performance issues in areas with large undefined flow regions. This is an advanced parameter only available in the Python API. When chunk_size exceeds this value, flat resolution will use this smaller chunk size instead</p> <code>512</code> Source code in <code>src/overflow/__init__.py</code> <pre><code>def flow_direction(\n    input_path: str,\n    output_path: str,\n    chunk_size: int = DEFAULT_CHUNK_SIZE,\n    working_dir: str | None = None,\n    resolve_flats: bool = True,\n    progress_callback: ProgressCallback | None = None,\n    flat_resolution_chunk_size_max: int = 512,\n) -&gt; None:\n    \"\"\"\n    Compute D8 flow directions from a DEM and optionally resolve flat areas.\n\n    This function calculates the steepest descent direction for each cell using\n    the D8 algorithm, then optionally resolves flat areas to ensure continuous\n    flow paths.\n\n    Args:\n        input_path: Path to the input DEM raster file (should be hydrologically\n            conditioned, e.g., filled or breached).\n        output_path: Path for the output flow direction raster file.\n        chunk_size: Size of processing chunks in pixels. Use chunk_size &lt;= 1 for\n            in-memory processing. Default is 2048.\n        working_dir: Directory for temporary files during tiled processing.\n            If None, uses system temp directory.\n        resolve_flats: If True (default), resolve flat areas in the flow direction\n            raster to ensure water flows toward lower terrain.\n        progress_callback: Optional callback function for progress reporting.\n            Receives a float value between 0 and 1.\n        flat_resolution_chunk_size_max: Maximum chunk size for flat resolution processing.\n            Default is 512. This caps the chunk size used during flat resolution to prevent\n            performance issues in areas with large undefined flow regions. This is an advanced\n            parameter only available in the Python API. When chunk_size exceeds this value,\n            flat resolution will use this smaller chunk size instead\n    \"\"\"\n    # Compute initial flow directions\n    _flow_direction(input_path, output_path, chunk_size, progress_callback)\n\n    # Resolve flat areas if requested\n    if resolve_flats:\n        if chunk_size &lt;= 1:\n            _resolve_flats_core(input_path, output_path, None)\n        else:\n            _resolve_flats_tiled(\n                input_path,\n                output_path,\n                None,\n                min(chunk_size, flat_resolution_chunk_size_max),\n                working_dir,\n                progress_callback,\n            )\n</code></pre>"},{"location":"api/#overflow.accumulation","title":"overflow.accumulation","text":"<pre><code>accumulation(input_path, output_path, chunk_size=DEFAULT_CHUNK_SIZE, progress_callback=None)\n</code></pre> <p>Calculate flow accumulation from a flow direction raster.</p> <p>This function computes the number of upstream cells that flow into each cell, representing drainage area in cell units.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str</code> <p>Path to the input flow direction raster file.</p> required <code>output_path</code> <code>str</code> <p>Path for the output flow accumulation raster file.</p> required <code>chunk_size</code> <code>int</code> <p>Size of processing chunks in pixels. Use chunk_size &lt;= 1 for in-memory processing. Default is 2048.</p> <code>DEFAULT_CHUNK_SIZE</code> <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional callback function for progress reporting. Receives a float value between 0 and 1.</p> <code>None</code> Source code in <code>src/overflow/__init__.py</code> <pre><code>def accumulation(\n    input_path: str,\n    output_path: str,\n    chunk_size: int = DEFAULT_CHUNK_SIZE,\n    progress_callback: ProgressCallback | None = None,\n) -&gt; None:\n    \"\"\"\n    Calculate flow accumulation from a flow direction raster.\n\n    This function computes the number of upstream cells that flow into each\n    cell, representing drainage area in cell units.\n\n    Args:\n        input_path: Path to the input flow direction raster file.\n        output_path: Path for the output flow accumulation raster file.\n        chunk_size: Size of processing chunks in pixels. Use chunk_size &lt;= 1 for\n            in-memory processing. Default is 2048.\n        progress_callback: Optional callback function for progress reporting.\n            Receives a float value between 0 and 1.\n    \"\"\"\n    if chunk_size &lt;= 1:\n        _flow_accumulation(input_path, output_path)\n    else:\n        _flow_accumulation_tiled(input_path, output_path, chunk_size, progress_callback)\n</code></pre>"},{"location":"api/#overflow.streams","title":"overflow.streams","text":"<pre><code>streams(fac_path, fdr_path, output_dir, threshold, chunk_size=DEFAULT_CHUNK_SIZE, progress_callback=None)\n</code></pre> <p>Extract stream networks from flow accumulation and direction rasters.</p> <p>This function identifies stream cells based on a flow accumulation threshold and creates vector stream lines and junction points.</p> <p>Parameters:</p> Name Type Description Default <code>fac_path</code> <code>str</code> <p>Path to the input flow accumulation raster file.</p> required <code>fdr_path</code> <code>str</code> <p>Path to the input flow direction raster file.</p> required <code>output_dir</code> <code>str</code> <p>Directory for output stream files (streams.gpkg will be created).</p> required <code>threshold</code> <code>int</code> <p>Minimum flow accumulation value (cell count) to define a stream. Cells with accumulation &gt;= threshold are considered streams.</p> required <code>chunk_size</code> <code>int</code> <p>Size of processing chunks in pixels. Use chunk_size &lt;= 1 for in-memory processing. Default is 2048.</p> <code>DEFAULT_CHUNK_SIZE</code> <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional callback function for progress reporting. Receives a float value between 0 and 1.</p> <code>None</code> Source code in <code>src/overflow/__init__.py</code> <pre><code>def streams(\n    fac_path: str,\n    fdr_path: str,\n    output_dir: str,\n    threshold: int,\n    chunk_size: int = DEFAULT_CHUNK_SIZE,\n    progress_callback: ProgressCallback | None = None,\n) -&gt; None:\n    \"\"\"\n    Extract stream networks from flow accumulation and direction rasters.\n\n    This function identifies stream cells based on a flow accumulation threshold\n    and creates vector stream lines and junction points.\n\n    Args:\n        fac_path: Path to the input flow accumulation raster file.\n        fdr_path: Path to the input flow direction raster file.\n        output_dir: Directory for output stream files (streams.gpkg will be created).\n        threshold: Minimum flow accumulation value (cell count) to define a stream.\n            Cells with accumulation &gt;= threshold are considered streams.\n        chunk_size: Size of processing chunks in pixels. Use chunk_size &lt;= 1 for\n            in-memory processing. Default is 2048.\n        progress_callback: Optional callback function for progress reporting.\n            Receives a float value between 0 and 1.\n    \"\"\"\n    if chunk_size &lt;= 1:\n        _extract_streams_core(\n            fac_path, fdr_path, output_dir, threshold, progress_callback\n        )\n    else:\n        _extract_streams_tiled(\n            fac_path, fdr_path, output_dir, threshold, chunk_size, progress_callback\n        )\n</code></pre>"},{"location":"api/#overflow.basins","title":"overflow.basins","text":"<pre><code>basins(fdr_path, drainage_points_path, output_path, chunk_size=DEFAULT_CHUNK_SIZE, all_basins=False, fac_path=None, snap_radius=0, layer_name=None, progress_callback=None)\n</code></pre> <p>Delineate drainage basins from a flow direction raster and drainage points.</p> <p>This function labels each cell with the ID of its downstream drainage point, effectively delineating basin boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>fdr_path</code> <code>str</code> <p>Path to the input flow direction raster file.</p> required <code>drainage_points_path</code> <code>str</code> <p>Path to the drainage points vector file.</p> required <code>output_path</code> <code>str</code> <p>Path for the output basins raster file.</p> required <code>chunk_size</code> <code>int</code> <p>Size of processing chunks in pixels. Use chunk_size &lt;= 1 for in-memory processing. Default is 2048.</p> <code>DEFAULT_CHUNK_SIZE</code> <code>all_basins</code> <code>bool</code> <p>If True, label all basins including those not draining to specified points. Default is False.</p> <code>False</code> <code>fac_path</code> <code>str | None</code> <p>Path to flow accumulation raster for snapping drainage points. If None, no snapping is performed.</p> <code>None</code> <code>snap_radius</code> <code>int</code> <p>Radius in cells to search for nearest drainage point. If 0, no snapping is performed.</p> <code>0</code> <code>layer_name</code> <code>str | None</code> <p>Name of the layer in the drainage points file to use. If None, uses the first layer.</p> <code>None</code> <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional callback function for progress reporting. Receives a float value between 0 and 1.</p> <code>None</code> Source code in <code>src/overflow/__init__.py</code> <pre><code>def basins(\n    fdr_path: str,\n    drainage_points_path: str,\n    output_path: str,\n    chunk_size: int = DEFAULT_CHUNK_SIZE,\n    all_basins: bool = False,\n    fac_path: str | None = None,\n    snap_radius: int = 0,\n    layer_name: str | None = None,\n    progress_callback: ProgressCallback | None = None,\n) -&gt; None:\n    \"\"\"\n    Delineate drainage basins from a flow direction raster and drainage points.\n\n    This function labels each cell with the ID of its downstream drainage point,\n    effectively delineating basin boundaries.\n\n    Args:\n        fdr_path: Path to the input flow direction raster file.\n        drainage_points_path: Path to the drainage points vector file.\n        output_path: Path for the output basins raster file.\n        chunk_size: Size of processing chunks in pixels. Use chunk_size &lt;= 1 for\n            in-memory processing. Default is 2048.\n        all_basins: If True, label all basins including those not draining to\n            specified points. Default is False.\n        fac_path: Path to flow accumulation raster for snapping drainage points.\n            If None, no snapping is performed.\n        snap_radius: Radius in cells to search for nearest drainage point.\n            If 0, no snapping is performed.\n        layer_name: Name of the layer in the drainage points file to use.\n            If None, uses the first layer.\n        progress_callback: Optional callback function for progress reporting.\n            Receives a float value between 0 and 1.\n    \"\"\"\n    drainage_points, fid_mapping = _drainage_points_from_file(\n        fdr_path, drainage_points_path, layer_name\n    )\n    # Snap drainage points to flow accumulation grid if fac_file is provided\n    if fac_path is not None and snap_radius &gt; 0:\n        drainage_points, fid_mapping = _snap_drainage_points(\n            drainage_points, fac_path, snap_radius, fid_mapping\n        )\n    if chunk_size &lt;= 1:\n        graph = _label_watersheds_core(\n            fdr_path, drainage_points, output_path, all_basins\n        )\n    else:\n        drainage_points, _ = _drainage_points_from_file(\n            fdr_path, drainage_points_path, layer_name\n        )\n        graph = _label_watersheds_tiled(\n            fdr_path,\n            drainage_points,\n            output_path,\n            chunk_size,\n            all_basins,\n            progress_callback,\n        )\n    # Update drainage points file with basin_id and ds_basin_id\n    _update_drainage_points_file(\n        drainage_points_path, drainage_points, fid_mapping, graph, layer_name\n    )\n</code></pre>"},{"location":"api/#overflow.flow_length","title":"overflow.flow_length","text":"<pre><code>flow_length(fdr_path, drainage_points_path, output_raster, output_vector=None, fac_path=None, snap_radius=0, layer_name=None)\n</code></pre> <p>Calculate upstream flow length (longest flow path) from drainage points.</p> <p>This function calculates the distance from each cell to its downstream drainage point, measured along the flow path. The cell with the maximum flow length in each basin represents the longest flow path origin.</p> <p>Parameters:</p> Name Type Description Default <code>fdr_path</code> <code>str</code> <p>Path to the input flow direction raster file.</p> required <code>drainage_points_path</code> <code>str</code> <p>Path to the drainage points vector file.</p> required <code>output_raster</code> <code>str</code> <p>Path for the output flow length raster file (GeoTIFF). Values represent upstream flow distance in map units (or meters for geographic CRS).</p> required <code>output_vector</code> <code>str | None</code> <p>Path for the output longest flow path vectors (GeoPackage). If None, vector output is not created.</p> <code>None</code> <code>fac_path</code> <code>str | None</code> <p>Path to flow accumulation raster for snapping drainage points. If None, no snapping is performed.</p> <code>None</code> <code>snap_radius</code> <code>int</code> <p>Radius in cells to search for maximum flow accumulation when snapping drainage points. If 0 or fac_path is None, no snapping.</p> <code>0</code> <code>layer_name</code> <code>str | None</code> <p>Name of the layer in the drainage points file to use. If None, uses the first layer.</p> <code>None</code> Source code in <code>src/overflow/__init__.py</code> <pre><code>def flow_length(\n    fdr_path: str,\n    drainage_points_path: str,\n    output_raster: str,\n    output_vector: str | None = None,\n    fac_path: str | None = None,\n    snap_radius: int = 0,\n    layer_name: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Calculate upstream flow length (longest flow path) from drainage points.\n\n    This function calculates the distance from each cell to its downstream\n    drainage point, measured along the flow path. The cell with the maximum\n    flow length in each basin represents the longest flow path origin.\n\n    Args:\n        fdr_path: Path to the input flow direction raster file.\n        drainage_points_path: Path to the drainage points vector file.\n        output_raster: Path for the output flow length raster file (GeoTIFF).\n            Values represent upstream flow distance in map units (or meters\n            for geographic CRS).\n        output_vector: Path for the output longest flow path vectors (GeoPackage).\n            If None, vector output is not created.\n        fac_path: Path to flow accumulation raster for snapping drainage points.\n            If None, no snapping is performed.\n        snap_radius: Radius in cells to search for maximum flow accumulation\n            when snapping drainage points. If 0 or fac_path is None, no snapping.\n        layer_name: Name of the layer in the drainage points file to use.\n            If None, uses the first layer.\n    \"\"\"\n    _flow_length_core(\n        fdr_path,\n        drainage_points_path,\n        output_raster,\n        output_vector,\n        layer_name,\n        fac_path,\n        snap_radius,\n    )\n</code></pre>"},{"location":"api/#utilities-types","title":"Utilities &amp; Types","text":""},{"location":"api/#overflow.FlowDirection","title":"overflow.FlowDirection","text":"<p>               Bases: <code>IntEnum</code></p> <p>D8 flow direction codes.</p> <p>These codes represent the eight cardinal and intercardinal directions plus special values for undefined flow and nodata cells.</p> <p>The numeric values correspond to the index in the neighbor offset array, starting from East (0) and going counter-clockwise.</p> 3 2 1 4 8 0 5 6 7"},{"location":"api/#overflow.ProgressCallback","title":"overflow.ProgressCallback","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for progress reporting callbacks.</p> <p>This protocol implements a hierarchical progress structure designed to track long-running hydrological operations.</p> <p>The hierarchy levels are:</p> <ul> <li>Phase: High-level operation (e.g., 'Breaching paths').</li> <li>Step: Named sub-operation within a phase (e.g., 'Process chunks').</li> <li>Message: Detail within a step (e.g., 'Chunk 28/36').</li> <li>Progress: Float (0.0-1.0) representing completion of the current step.</li> </ul> <p>Implementations should be callable with the following signature:</p> <pre><code>def callback(\n    phase: str | None = None,\n    step_name: str | None = None,\n    step_number: int = 0,\n    total_steps: int = 0,\n    message: str = \"\",\n    progress: float = 0.0,\n) -&gt; None: ...\n</code></pre> <p>Where:</p> <ul> <li>phase: The name of the high-level phase. If <code>None</code>, the previously   set phase is preserved.</li> <li>step_name: The name of the current step within the phase. If <code>None</code>,   the previously set step is preserved.</li> <li>step_number: The current step number (1-indexed).</li> <li>total_steps: The total number of steps expected in this phase.</li> <li>message: A detailed status message regarding the current activity.</li> <li>progress: The normalized progress of the current step (0.0 to 1.0).</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>The Overflow Command Line Interface (CLI) provides access to all core hydrological analysis tools.</p>"},{"location":"cli/#usage","title":"Usage","text":"<p>All commands are invoked via the <code>overflow</code> entry point:</p> <pre><code>overflow [COMMAND] [OPTIONS]\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#pipeline","title":"<code>pipeline</code>","text":"<p>Description: Run the complete DEM processing pipeline. This command runs a full hydrological analysis workflow: </p> <ol> <li>Breach pits (optional, if search_radius_ft &gt; 0)</li> <li>Fill depressions</li> <li>Compute flow direction (with flat resolution)</li> <li>Calculate flow accumulation</li> <li>Extract streams</li> <li>Delineate watersheds (optional, if --basins flag is set)</li> </ol> <p>Options:</p> Option Type Default Required Description <code>--dem_file</code> TEXT - Yes Path to the GDAL supported raster dataset for the DEM. <code>--output_dir</code> TEXT - Yes Path to the output directory. <code>--chunk_size</code> INTEGER 2048 No Chunk size (use \\&lt;= 0 for in-memory processing). <code>--search_radius_ft</code> FLOAT 200 No Search radius in feet for pit breaching (0 to skip breaching). <code>--max_cost</code> FLOAT inf No Maximum cost of breach paths (total sum of elevation removed from each cell in path). <code>--da_sqmi</code> FLOAT 1 No Minimum drainage area in square miles for stream extraction. <code>--basins</code> FLAG False No Flag to enable watershed delineation. <code>--fill_holes</code> FLAG False No If set, fills holes in the DEM."},{"location":"cli/#breach","title":"<code>breach</code>","text":"<p>Description: Breach pits in a DEM using least-cost paths. This command identifies pits (local minima) in the DEM and creates breach paths to allow water to flow out, minimizing the total elevation change. </p> <p>Options:</p> Option Type Default Required Description <code>--input_file</code> TEXT - Yes Path to the GDAL supported raster dataset for the DEM. <code>--output_file</code> TEXT - Yes Path to the output file (must be GeoTiff). <code>--chunk_size</code> INTEGER 2048 No Chunk size. <code>--search_radius</code> INTEGER 200 No Search radius in cells. <code>--max_cost</code> FLOAT inf No Maximum cost of breach paths."},{"location":"cli/#fill","title":"<code>fill</code>","text":"<p>Description: Fill depressions in a DEM using priority flood algorithm. This command fills local depressions (sinks) in the DEM to create a hydrologically conditioned surface where water can flow to the edges.</p> <p>Options:</p> Option Type Default Required Description <code>--input_file</code> TEXT - Yes Path to the GDAL supported raster dataset for the DEM. <code>--output_file</code> TEXT None No Path to the output file. If not provided, modifies input in place. <code>--chunk_size</code> INTEGER 2048 No Chunk size (use \\&lt;= 1 for in-memory processing). <code>--working_dir</code> TEXT None No Working directory for temporary files. <code>--fill_holes</code> FLAG False No If set, fills holes (nodata regions) in the DEM."},{"location":"cli/#flow-direction","title":"<code>flow-direction</code>","text":"<p>Description: Compute D8 flow directions from a DEM and resolve flat areas. This command calculates the steepest descent direction for each cell using the D8 algorithm, then resolves flat areas to ensure continuous flow paths. </p> <p>Options:</p> Option Type Default Required Description <code>--input_file</code> TEXT - Yes Path to the DEM file. <code>--output_file</code> TEXT - Yes Path to the output file. <code>--chunk_size</code> INTEGER 2048 No Chunk size (use \\&lt;= 1 for in-memory processing). <code>--working_dir</code> TEXT None No Working directory for temporary files. <code>--no_resolve_flats</code> FLAG False No If set, skip resolving flat areas."},{"location":"cli/#accumulation","title":"<code>accumulation</code>","text":"<p>Description: Calculate flow accumulation from a flow direction raster. This command computes the number of upstream cells that flow into each cell, representing drainage area in cell units.</p> <p>Options:</p> Option Type Default Required Description <code>--input_file</code> TEXT - Yes Path to the GDAL supported raster dataset for the flow direction raster. <code>--output_file</code> TEXT - Yes Path to the output file (must be GeoTiff). <code>--chunk_size</code> INTEGER 2048 No Chunk size (use \\&lt;= 1 for in-memory processing)."},{"location":"cli/#streams","title":"<code>streams</code>","text":"<p>Description: Extract stream networks from flow accumulation and direction rasters. This command identifies stream cells based on a flow accumulation threshold and creates vector stream lines and junction points (streams.gpkg).</p> <p>Options:</p> Option Type Default Required Description <code>--fac_file</code> TEXT - Yes Path to the flow accumulation raster. <code>--fdr_file</code> TEXT - Yes Path to the flow direction raster. <code>--output_dir</code> TEXT - Yes Path to the output directory. <code>--threshold</code> INTEGER 5 No Minimum flow accumulation threshold (cell count) to define a stream. <code>--chunk_size</code> INTEGER 2048 No Chunk size (use \\&lt;= 1 for in-memory processing)."},{"location":"cli/#basins","title":"<code>basins</code>","text":"<p>Description: Delineate drainage basins from a flow direction raster and drainage points. This command labels each cell with the ID of its downstream drainage point, effectively delineating basin boundaries.</p> <p>Options:</p> Option Type Default Required Description <code>--fdr_file</code> TEXT - Yes Path to the flow direction raster. <code>--dp_file</code> TEXT - Yes Path to the drainage points file. <code>--output_file</code> TEXT - Yes Path to the output file (must be GeoTiff). <code>--fac_file</code> TEXT None No Path to the flow accumulation raster (optional, for snapping). <code>--dp_layer</code> TEXT None No Name of the layer in the drainage points file. <code>--snap_radius_ft</code> FLOAT 0 No Radius in feet to snap drainage points to maximum flow accumulation. <code>--all_basins</code> BOOL False No If True, labels all basins. If False, only labels basins upstream of drainage points. <code>--chunk_size</code> INTEGER 2048 No Chunk size (use \\&lt;= 1 for in-memory processing)."},{"location":"cli/#flow-length","title":"<code>flow-length</code>","text":"<p>Description: Calculate upstream flow length (longest flow path) from drainage points. This command calculates the distance from each cell to its downstream drainage point, measured along the flow path. The output raster contains flow length values in map units.</p> <p>Options:</p> Option Type Default Required Description <code>--fdr_file</code> TEXT - Yes Path to the flow direction raster. <code>--dp_file</code> TEXT - Yes Path to the drainage points file. <code>--output_raster</code> TEXT - Yes Path to the output raster file (must be GeoTiff). <code>--output_vector</code> TEXT None No Path to the output vector file (GeoPackage) for longest flow paths. <code>--fac_file</code> TEXT None No Path to the flow accumulation raster (optional, for snapping). <code>--dp_layer</code> TEXT None No Name of the layer in the drainage points file. <code>--snap_radius_ft</code> FLOAT 0 No Radius in feet to snap drainage points to maximum flow accumulation."},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers different methods to install Overflow and its dependencies.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":""},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<p>Overflow is not comprehensively tested across all platforms. The recommended environment is:</p> <ul> <li>x86_64 or ARM64 architecture</li> <li>Linux operating system</li> <li>Python 3.11 or 3.12</li> <li>GDAL 3.12 with Python bindings and numpy support</li> </ul> <p>Other platforms like macOS/Windows and other versions of Python/GDAL may work but are not officially tested and supported.</p>"},{"location":"getting-started/installation/#python-dependencies","title":"Python Dependencies","text":"<p>The following Python packages are automatically installed:</p> <ul> <li>NumPy &gt;= 1.26.4, &lt;2</li> <li>Numba &gt;= 0.59.0</li> <li>Shapely &gt;= 2.0.6</li> <li>Rich &gt;= 13.9.4</li> <li>Click &gt;= 8.0.0</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-micromamba-recommended","title":"Method 1: Micromamba (Recommended)","text":"<p>The recommended installation method uses conda/mamba to handle GDAL's installation.:</p> <pre><code># Create a new environment with GDAL\nmicromamba create -n overflow python \\\n    gdal \\\n    -c conda-forge\n\n# Activate the environment\nconda activate overflow\n\n# Install overflow from PyPI\npip install overflow-hydro\n</code></pre>"},{"location":"getting-started/installation/#method-2-docker-easiest","title":"Method 2: Docker (Easiest)","text":"<p>Docker provides a completely pre-configured environment with all dependencies:</p> <pre><code># Pull the latest image\ndocker pull ghcr.io/fema-ffrd/overflow:latest\n\n# Run overflow commands\ndocker run -it -v $(pwd)/data:/mnt/data ghcr.io/fema-ffrd/overflow:latest \\\n    pipeline \\\n    --dem_file /mnt/data/dem.tif \\\n    --output_dir /mnt/data/results\n</code></pre>"},{"location":"getting-started/installation/#method-3-pip-with-system-gdal","title":"Method 3: pip with System GDAL","text":"<p>If you have GDAL already installed on your system, you can install Overflow with pip or uv:</p> <pre><code># Install overflow (requires system GDAL)\nuv pip install overflow-hydro\n\n# Optional: Install with GDAL Python bindings\nuv pip install overflow-hydro[gdal]\n</code></pre> <p>Manual GDAL Installation Required</p> <p>This method requires you to install GDAL system libraries manually. This can be complex on some platforms.</p>"},{"location":"getting-started/installation/#installing-gdal-system-libraries","title":"Installing GDAL System Libraries","text":"Ubuntu/DebianBrew (macOS)Windows <pre><code>sudo apt-get update\nsudo apt-get install gdal-bin libgdal-dev python3-gdal\n\n# Install overflow\nuv pip install overflow-hydro\n</code></pre> <pre><code>brew install gdal\n\n# Install overflow\nuv pip install overflow-hydro\n</code></pre> <pre><code># Use conda or OSGeo4W installer\n# https://trac.osgeo.org/osgeo4w/\n\n# Then install overflow\nuv pip install overflow-hydro\n</code></pre>"},{"location":"getting-started/installation/#method-4-development-installation","title":"Method 4: Development Installation","text":"<p>For contributing or running the latest development version:</p> <pre><code># Clone the repository\ngit clone https://github.com/fema-ffrd/overflow.git\ncd overflow\n\n# Create conda environment with GDAL\nconda create -n overflow-dev python gdal -c conda-forge\nconda activate overflow-dev\n\n# Install in development mode with dev dependencies\nuv pip install -e \".[dev]\"\n\n# Verify installation\npytest\n</code></pre> <p>Alternatively, you can use the devcontainer provided with the repository for a pre-configured development environment (recommended).</p>"},{"location":"introduction/overview/","title":"Overview","text":"<p>Overflow is a high-performance Python library designed for processing Digital Elevation Models (DEMs) at scale. The library addresses the computational challenges of hydrological terrain analysis when working with massive raster datasets that can range from local watersheds to continental-scale terrain models.</p>"},{"location":"introduction/overview/#what-overflow-does","title":"What Overflow Does","text":"<p>Overflow provides a complete suite of tools for deriving hydrographic features from raw elevation data. The library handles the full processing pipeline from terrain conditioning through feature extraction. This includes removing artifacts and depressions in the elevation data, computing how water flows across the landscape, calculating drainage area, and extracting vector representations of stream networks and basin boundaries.</p>"},{"location":"introduction/overview/#who-should-use-overflow","title":"Who Should Use Overflow","text":"<p>Overflow is designed for anyone who needs to run these hydrolocial process on large DEMs efficiently. The library is particularly valuable when working with datasets that exceed the practical limits of traditional single-threaded tools or when processing time is a critical constraint.</p> <p>Users should have basic familiarity with hydrological concepts such as flow direction, flow accumulation, and drainage networks. The library assumes you are comfortable working with geospatial raster data and understand fundamental GIS concepts. Programming experience with Python is helpful for using the API, though the command-line interface provides access to core functionality without requiring code.</p>"},{"location":"introduction/overview/#design-philosophy","title":"Design Philosophy","text":"<p>Overflow prioritizes scalability and performance while maintaining correctness. The algorithms make practical trade-offs that enable efficient processing of massive datasets. Most of the algorithms produce results that are mathematically equivalent to authoritative methods used throughout the hydrological community.</p>"},{"location":"introduction/overview/#the-scaling-problem","title":"The Scaling Problem","text":"<p>Raster processing algorithms vary significantly in complexity. While most tools can easily parallelize simple tasks, Overflow is specifically engineered to handle the \"hard\" problems in hydrology. These can be broadly categorized into three classes based on their computational complexity and data dependencies:</p>"},{"location":"introduction/overview/#local-operations","title":"Local Operations","text":"<p>Mathematically, a local operation maps a single input value to a single output value using a function \\(f\\). There are no spatial dependencies. If \\(I\\) is the input raster and \\(O\\) is the output raster, then for each pixel at row \\(i\\) and column \\(j\\):</p> \\[ O_{i,j} = f(I_{i,j}) \\] <p>These operations consider each pixel in isolation. They are computationally inexpensive and trivial to parallelize because no information needs to be shared between pixels. These include operations like reclassifying elevation ranges (e.g., converting meters to feet) or calculating NDVI from imagery.</p>"},{"location":"introduction/overview/#focal-regional-operations","title":"Focal / Regional Operations","text":"<p>These operations calculate a value based on a pixel and its immediate neighbors (e.g., a 3x3 window). Parallelizing these requires \"halo\" or buffer regions around tiles to ensure edge pixels can see their neighbors in adjacent tiles. These include operations like calculating flow direction, slope, or local relief. Mathematically, a focal operation can be expressed as:</p> \\[ O_{i,j} = f\\left( \\{ I_{u,v} \\mid u \\in [i-k, i+k], v \\in [j-k, j+k] \\} \\right) \\] <p>Where \\(k\\) defines the size of the neighborhood.</p>"},{"location":"introduction/overview/#global-operations","title":"Global Operations","text":"<p>These are the most computationally difficult algorithms to parallelize because the value of a single pixel can depend on any other pixel in the entire raster, regardless of distance. A change in elevation at one edge of the map can affect flow accumulation at the opposite edge. Unfortunately, these global operations include most of the useful hydrological processes. Flow accumulation, depression filling, undefined flow direction resolution, basin delineation, longest flow paths and stream network extraction are all global operations.</p> <p>Most global algorithms in hydrology are defined recursively, making them inherently sequential. The value at a pixel depends on the topology of the flow network.</p> \\[ O_{i,j} = f\\left( \\{ I_{u,v} \\mid (u,v) \\in \\mathcal{P}_{(i,j)} \\} \\right) \\] <p>Where \\(P(i,j)\\)\u200b is the set of all pixels forming a directed path ending at \\((i,j)\\).</p> <p>You cannot compute \\(O_{i,j}\\) without resolving the state of pixels potentially located at the opposite end of the raster. This necessitates a graph-based approach. Overflow solves these global problems by processing data tile-by-tile to construct a connectivity graph, followed by a finalization pass that resolves dependencies across the entire domain.</p>"},{"location":"introduction/quickstart/","title":"Quick Start","text":"<p>The pipeline command executes terrain conditioning, flow routing, and feature extraction from a DEM. Stream network output is generated automatically. Basin delineation is optional.</p>"},{"location":"introduction/quickstart/#installation","title":"Installation","text":"<p>Installation procedures are documented in Installation Guide.</p>"},{"location":"introduction/quickstart/#pipeline-command","title":"Pipeline Command","text":""},{"location":"introduction/quickstart/#cli-usage","title":"CLI Usage","text":"<p>Basic execution:</p> <pre><code>overflow pipeline \\\n    --dem_file dem.tif \\\n    --output_dir ./results\n</code></pre> <p>Output files in <code>./results/</code>:</p> <ul> <li><code>dem_breached.tif</code> - Breached DEM (float32)</li> <li><code>dem_filled.tif</code> - Filled DEM (float32)</li> <li><code>fdr.tif</code> - D8 flow directions (byte)</li> <li><code>accum.tif</code> - Upstream cell count (int64)</li> <li><code>streams.gpkg</code> - Vector stream network with junctions</li> </ul> <p>Note</p> <p>The output directory must exist. It will not be created if it does not.</p> <p>Note</p> <p>If files with the same names existing in the output directory they will be overwritten.</p> <p>By default both breaching and filling is performed. The default breach search radius is 200 feet. Modify with <code>--search_radius_ft</code>:</p> <pre><code>overflow pipeline \\\n    --dem_file dem.tif \\\n    --output_dir ./results \\\n    --search_radius_ft 300\n</code></pre> <p>Disable breaching with <code>--search_radius_ft 0</code>. Pipeline will only fill depressions. Filling cannot be disabled.</p> <p>Control stream density with <code>--da_sqmi</code> parameter (drainage area threshold in square miles):</p> <pre><code>overflow pipeline \\\n    --dem_file dem.tif \\\n    --output_dir ./results \\\n    --da_sqmi 0.5\n</code></pre> <p>Lower values produce denser networks. Higher values extract major channels only.</p> <p>Delineate basins with the <code>--basins</code> parameter:</p> <pre><code>overflow pipeline \\\n    --dem_file dem.tif \\\n    --output_dir ./results \\\n    --da_sqmi 0.5 \\\n    --basins\n</code></pre> <p>Basins will automatically be generated at the downstream end of each reach and at the upstream most points in the stream network.</p>"},{"location":"introduction/quickstart/#docker-usage","title":"Docker Usage","text":"<p>Pull image:</p> <pre><code>docker pull ghcr.io/fema-ffrd/overflow:latest\n</code></pre> <p>Execute with volume mount:</p> <pre><code>docker run -v $(pwd)/data:/mnt/data \\\n    ghcr.io/fema-ffrd/overflow:latest \\\n    pipeline \\\n    --dem_file /mnt/data/dem.tif \\\n    --output_dir /mnt/data/results\n</code></pre> <p>File paths reference container mount point <code>/mnt/data</code>.</p>"},{"location":"introduction/quickstart/#python-api","title":"Python API","text":"<p>Sequential function calls provide fine-grained control:</p> <pre><code>import overflow\n\noverflow.breach(\"dem.tif\", \"dem_breached.tif\")\noverflow.fill(\"dem_breached.tif\", \"dem_filled.tif\")\noverflow.flow_direction(\"dem_filled.tif\", \"fdr.tif\")\noverflow.accumulation(\"fdr.tif\", \"fac.tif\")\noverflow.streams(\"fac.tif\", \"fdr.tif\", \"./output\", threshold=100)\noverflow.basins(\"fdr.tif\", \"./output/streams.gpkg\", \"./output\", layer_name=\"junctions\")\n</code></pre> <p>Note</p> <p>In the Python API, all units are in cell counts or map units. No projection or conversions are performed.</p> <p>Note</p> <p>The streams.gpkg will contain a \"junctions\" layer with points at the downstream ends of each reach and at the upstream ends of the stream network.</p>"},{"location":"introduction/quickstart/#input-requirements","title":"Input Requirements","text":"<p>DEM constraints:</p> <ul> <li>GDAL-readable format (e.g., GeoTIFF)</li> <li>Single-band float32</li> </ul> <p>Warning</p> <p>A projected coordinate system with consistent horizontal and vertical units is recommended for best results.</p>"},{"location":"introduction/quickstart/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>User Guide - Operation details</li> <li>API Reference - Function signatures</li> <li>CLI Reference - Command documentation</li> <li>Algorithm Details - Implementation and theory</li> </ul>"},{"location":"user-guide/pipeline/","title":"Pipeline","text":""},{"location":"user-guide/pipeline/#purpose","title":"Purpose","text":"<p>The Pipeline command is a high-level orchestrator that executes a complete hydrological analysis workflow in a single command. It automates the sequence of terrain conditioning, flow routing, and feature extraction, managing intermediate file creation and dependency handling automatically.</p>"},{"location":"user-guide/pipeline/#when-to-use","title":"When to Use","text":"<p>Use the pipeline when you need to derive standard hydrographic features from a raw DEM without manually managing the sequence of individual operations. It is ideal for:</p> <ul> <li>Batch Processing: Automating analysis across many DEMs.</li> <li>Standard Workflows: Ensuring consistent processing steps.</li> <li>Quick Analysis: Getting from a raw DEM to streams and basins with minimal configuration.</li> </ul>"},{"location":"user-guide/pipeline/#workflow-steps","title":"Workflow Steps","text":"<p>The pipeline executes the following operations in order:</p> <ol> <li>Breach: Removes pits by carving paths (optional, dependent on search radius).</li> <li>Fill: Fills remaining depressions to ensure hydrologic conditioning.</li> <li>Flow Direction: Computes D8 flow direction with flat resolution.</li> <li>Flow Accumulation: Calculates upstream drainage area.</li> <li>Stream Extraction: Vectorizes stream networks based on drainage area threshold.</li> <li>Basin Delineation: (Optional) Delineates watersheds for stream junctions.</li> </ol>"},{"location":"user-guide/pipeline/#parameters","title":"Parameters","text":""},{"location":"user-guide/pipeline/#dem_file","title":"dem_file","text":"<p>Path to the input raw DEM raster. GDAL-readable format. Single band. Float32.</p>"},{"location":"user-guide/pipeline/#output_dir","title":"output_dir","text":"<p>Directory where all output files will be written. The directory must exist. Existing files with generated names (e.g., <code>fdr.tif</code>) will be overwritten.</p>"},{"location":"user-guide/pipeline/#chunk_size","title":"chunk_size","text":"<p>Tile dimension in pixels for processing. Default 2048. Set to 0 for in-memory processing.</p>"},{"location":"user-guide/pipeline/#search_radius_ft","title":"search_radius_ft","text":"<p>Search radius in feet for the pit breaching step. Default: 200. If set to 0, the breaching step is skipped, and the pipeline relies solely on filling. Internal conversion to cell count is performed based on the raster's spatial reference.</p>"},{"location":"user-guide/pipeline/#max_cost","title":"max_cost","text":"<p>Maximum elevation cost for the breaching step. Default infinity. See Breach </p>"},{"location":"user-guide/pipeline/#da_sqmi","title":"da_sqmi","text":"<p>Drainage area threshold in square miles for stream extraction. Default: 1.0. Internal conversion to cell count is performed based on the raster's spatial reference. Determines the density of the resulting stream network.</p>"},{"location":"user-guide/pipeline/#basins","title":"basins","text":"<p>Flag to enable watershed delineation. If set, basins are delineated for every junction node in the extracted stream network. Outputs a <code>basins.tif</code> raster and <code>basins.gpkg</code> vector.</p>"},{"location":"user-guide/pipeline/#fill_holes","title":"fill_holes","text":"<p>Flag to fill nodata holes in the DEM during the conditioning phase. See Fill</p>"},{"location":"user-guide/pipeline/#outputs","title":"Outputs","text":"<p>The pipeline generates the following files in the <code>output_dir</code>:</p> Filename Description Data Type <code>dem_corrected.tif</code> Hydrologically conditioned DEM (Breached &amp; Filled) Float32 <code>fdr.tif</code> D8 Flow Direction Raster UInt8 <code>accum.tif</code> Flow Accumulation Raster Int64 <code>streams.gpkg</code> GeoPackage containing <code>streams</code> (lines) and <code>junctions</code> (points) Vector <code>basins.tif</code> Basin ID Raster (created only if <code>--basins</code> is used) Int64 <code>basins.gpkg</code> GeoPackage containing <code>basins</code> (created only if <code>--basins</code> is used) Vector"},{"location":"user-guide/pipeline/#cli-usage","title":"CLI Usage","text":"<p>Run the full pipeline with breaching, stream extraction (1 sq mi threshold), and basin delineation:</p> <pre><code>overflow pipeline \\\n    --dem_file raw_dem.tif \\\n    --output_dir ./results \\\n    --search_radius_ft 200 \\\n    --da_sqmi 1.0 \\\n    --basins\n</code></pre> <p>Run a fill-only pipeline (skip breaching) for a dense network (0.1 sq mi):</p> <pre><code>overflow pipeline \\\n    --dem_file raw_dem.tif \\\n    --output_dir ./results \\\n    --search_radius_ft 0 \\\n    --da_sqmi 0.1\n</code></pre>"},{"location":"user-guide/pipeline/#python-api-usage","title":"Python API Usage","text":"<p>The <code>pipeline</code> function is primarily a CLI convenience wrapper. To replicate the pipeline logic in Python, invoke the individual core functions sequentially. This allows for greater control over intermediate filenames and parameters.</p> <pre><code>import overflow\n\n# 1. Setup paths\ndem_file = \"raw_dem.tif\"\noutput_dir = \"./results\"\n\n# 2. Terrain Conditioning (Breach + Fill)\n# Note: Python API uses cell count\nradius_cells = 50\n\noverflow.breach(dem_file, f\"{output_dir}/dem_breached.tif\", search_radius=radius_cells)\noverflow.fill(f\"{output_dir}/dem_breached.tif\", f\"{output_dir}/dem_corrected.tif\")\n\n# 3. Flow Routing\noverflow.flow_direction(f\"{output_dir}/dem_corrected.tif\", f\"{output_dir}/fdr.tif\")\noverflow.accumulation(f\"{output_dir}/fdr.tif\", f\"{output_dir}/accum.tif\")\n\n# 4. Feature Extraction\nthreshold_cells = 50000\n\noverflow.streams(\n    fac_path=f\"{output_dir}/accum.tif\",\n    fdr_path=f\"{output_dir}/fdr.tif\",\n    output_dir=output_dir,\n    threshold=threshold_cells\n)\n\n# 5. Basins\n# Uses the junctions layer from the generated streams.gpkg\noverflow.basins(\n    fdr_path=f\"{output_dir}/fdr.tif\",\n    drainage_points_path=f\"{output_dir}/streams.gpkg\",\n    output_path=f\"{output_dir}/basins.tif\",\n    layer_name=\"junctions\"\n)\n</code></pre>"},{"location":"user-guide/pipeline/#see-also","title":"See Also","text":"<ul> <li>Breach - Details on the breaching algorithm</li> <li>Fill - Details on the filling algorithm</li> <li>Stream Extraction - Details on stream vectorization</li> <li>Basin Delineation - Details on watershed delineation</li> </ul>"},{"location":"user-guide/feature-extraction/basins/","title":"Basin Delineation","text":""},{"location":"user-guide/feature-extraction/basins/#purpose","title":"Purpose","text":"<p>Basin delineation assigns each cell a label identifying its downstream drainage point. The output raster contains unique basin IDs corresponding to its most immediate downstream drainage point. Drainage points can be snapped to the flow accumulation raster and the provided drainage points are attributed in place with the generated basin ID and their downstream basin ID.</p>"},{"location":"user-guide/feature-extraction/basins/#parameters","title":"Parameters","text":""},{"location":"user-guide/feature-extraction/basins/#fdr_path","title":"fdr_path","text":"<p>Path to flow direction raster. GDAL-readable format. Single band. UInt8 data type. Values 0-7 represent valid flow directions. Nodata value 9. Must have all non-nodata cells with defined flow directions.</p>"},{"location":"user-guide/feature-extraction/basins/#drainage_points_path","title":"drainage_points_path","text":"<p>Path to drainage points vector file. Any GDAL-readable vector format (Shapefile, GeoPackage, GeoJSON). Must contain point geometries. Points located outside raster extent or on nodata cells are invalid and ignored.</p>"},{"location":"user-guide/feature-extraction/basins/#output_path","title":"output_path","text":"<p>Path for basin raster output. Written as GeoTIFF. Int64 data type. Inherits projection and geotransform from flow direction input. Cell values have generated basin IDs. Nodata value -1.</p>"},{"location":"user-guide/feature-extraction/basins/#chunk_size","title":"chunk_size","text":"<p>Tile dimension in pixels. Default 2048. Set to 0 or 1 for in-memory processing.</p>"},{"location":"user-guide/feature-extraction/basins/#all_basins","title":"all_basins","text":"<p>Boolean flag controlling basin labeling scope. When False (default), only cells draining to specified drainage points are labeled. Cells draining elsewhere receive nodata (-1). When True, all cells labeled including those not draining to specified points (e.g., off map flow).</p>"},{"location":"user-guide/feature-extraction/basins/#fac_path","title":"fac_path","text":"<p>Path to flow accumulation raster for drainage point snapping. When provided with nonzero <code>snap_radius</code>, drainage points are moved to cell with maximum accumulation within snap radius. Ensures points snap to stream channels. When None, no snapping performed.</p>"},{"location":"user-guide/feature-extraction/basins/#snap_radius","title":"snap_radius","text":"<p>Snapping search radius in cells. When positive and <code>fac_path</code> provided, drainage points moved to maximum accumulation cell within radius. When 0, no snapping. Default 0.</p>"},{"location":"user-guide/feature-extraction/basins/#layer_name","title":"layer_name","text":"<p>Name of layer in vector file to read for the drainage points. When None, uses first layer. Relevant for multi-layer formats like GeoPackage.</p>"},{"location":"user-guide/feature-extraction/basins/#progress_callback","title":"progress_callback","text":"<p>Optional callback for monitoring long operations. See ProgressCallback API.</p>"},{"location":"user-guide/feature-extraction/basins/#cli-usage","title":"CLI Usage","text":"<pre><code>overflow basins \\\n    --fdr fdr.tif \\\n    --drainage_points streams.gpkg \\\n    --output basins.tif \\\n    --layer_name junctions\n</code></pre>"},{"location":"user-guide/feature-extraction/basins/#python-api-usage","title":"Python API Usage","text":"<pre><code>import overflow\n\noverflow.basins(\n    fdr_path=\"fdr.tif\",\n    drainage_points_path=\"streams.gpkg\",\n    output_path=\"basins.tif\"\n    layer_name=\"junctions\"\n)\n</code></pre> <p>The output cell values contain generated basin ID corresponding to their downstream drainage point. All cells draining to the same point share the same label. Nodata cells (-1) are propagated from the input. When <code>all_basins=True</code> basins draining off map but not to a provided draininge point are also included. The provided drainage points will be attributed with their basin IDs and downstream basin IDs.</p>"},{"location":"user-guide/feature-extraction/basins/#visualization","title":"Visualization","text":"DEM Basins"},{"location":"user-guide/feature-extraction/basins/#drainage-point-snapping","title":"Drainage Point Snapping","text":"<p>Snapping corrects drainage point locations that fall slightly off stream channels due to digitization error or CRS mismatch.</p> <p>Snapping requires accumulation raster with values representing upstream cell count. Without snapping, drainage points used at exact provided coordinates\u2014may not correspond to stream channel locations.</p>"},{"location":"user-guide/feature-extraction/basins/#drainage-point-requirements","title":"Drainage Point Requirements","text":"<p>Drainage points must satisfy:</p> <ul> <li>Point geometry type</li> <li>Located within raster extent</li> <li>Located on valid (non-nodata) cells</li> </ul>"},{"location":"user-guide/feature-extraction/basins/#using-stream-junctions-as-drainage-points","title":"Using Stream Junctions as Drainage Points","text":"<p>Common workflow combines stream extraction with basin delineation:</p> <pre><code>import overflow\n\n# Extract streams with junctions\noverflow.streams(\"accum.tif\", \"fdr.tif\", \"./output\", threshold=100)\n\n# Delineate basins at junctions\noverflow.basins(\n    fdr_path=\"fdr.tif\",\n    drainage_points_path=\"./output/streams.gpkg\",\n    output_path=\"basins.tif\",\n    layer_name=\"junctions\"\n)\n</code></pre>"},{"location":"user-guide/feature-extraction/basins/#see-also","title":"See Also","text":"<ul> <li>Flow Direction - Computing flow directions for basin delineation</li> <li>Stream Extraction - Generating drainage points at stream junctions</li> <li>Longest Flow Path - Computing flow path lengths within basins</li> <li>Complete Pipeline - End-to-end workflow</li> <li>Basin Delineation Algorithm - Implementation details</li> </ul>"},{"location":"user-guide/feature-extraction/flow-length/","title":"Longest Flow Path","text":""},{"location":"user-guide/feature-extraction/flow-length/#purpose","title":"Purpose","text":"<p>Flow length computes upstream distance from each cell to its downstream drainage point along the flow network. Maximum flow length in each basin identifies the longest flow path, representing the hydraulically most distant point from the outlet.</p>"},{"location":"user-guide/feature-extraction/flow-length/#parameters","title":"Parameters","text":""},{"location":"user-guide/feature-extraction/flow-length/#fdr_path","title":"fdr_path","text":"<p>Path to flow direction raster. GDAL-readable format. Single band. UInt8 data type. Values 0-7 represent valid flow directions. Nodata value 9. All non-nodata cells must have defined flow directions.</p>"},{"location":"user-guide/feature-extraction/flow-length/#drainage_points_path","title":"drainage_points_path","text":"<p>Path to drainage points vector file. Any GDAL-readable vector format. Must contain point geometries with unique FIDs. Points define basin outlets where flow length computation originates.</p>"},{"location":"user-guide/feature-extraction/flow-length/#output_raster","title":"output_raster","text":"<p>Path for flow length raster output. Written as GeoTIFF. Float32 data type. Values represent upstream flow distance in map units (meters for metric CRS, feet for US State Plane, etc.). Inherits projection and geotransform from flow direction input. Nodata value (-1).</p>"},{"location":"user-guide/feature-extraction/flow-length/#output_vector","title":"output_vector","text":"<p>Path for longest flow path vector output. Written as GeoPackage containing LineString geometries. Each line represents longest flow path for one basin traced from maximum flow length cell downstream to drainage point. When None, vector output not created.</p>"},{"location":"user-guide/feature-extraction/flow-length/#fac_path","title":"fac_path","text":"<p>Path to flow accumulation raster for drainage point snapping. When provided with nonzero <code>snap_radius</code>, drainage points are moved to cell with maximum accumulation within snap radius. Ensures points snap to stream channels. When None, no snapping performed.</p>"},{"location":"user-guide/feature-extraction/flow-length/#snap_radius","title":"snap_radius","text":"<p>Snapping search radius in cells. When positive and <code>fac_path</code> provided, drainage points moved to maximum accumulation cell within radius. When 0, no snapping. Default 0.</p>"},{"location":"user-guide/feature-extraction/flow-length/#layer_name","title":"layer_name","text":"<p>Name of layer in vector file to read. When None, uses first layer. Relevant for multi-layer formats like GeoPackage.</p>"},{"location":"user-guide/feature-extraction/flow-length/#cli-usage","title":"CLI Usage","text":"<pre><code>overflow flow-length \\\n    --fdr fdr.tif \\\n    --drainage_points outlets.shp \\\n    --output_raster flow_length.tif \\\n    --output_vector longest_paths.gpkg\n</code></pre>"},{"location":"user-guide/feature-extraction/flow-length/#python-api-usage","title":"Python API Usage","text":"<pre><code>import overflow\n\noverflow.flow_length(\n    fdr_path=\"fdr.tif\",\n    drainage_points_path=\"outlets.shp\",\n    output_raster=\"flow_length.tif\",\n    output_vector=\"longest_paths.gpkg\"\n)\n</code></pre> <p>The output raster will contain cell values representing the distance in map units (meters for geographic coordinate systems) along flow paths to the first downstream drainage point. Drainage point cells have value 0. Values increase monotonically following the flow paths upstream. Nodata cells in the flow direction propagate as nodata in the output</p> <p>The output vector (when generated) contains one LineString feature per drainage point with vertices corresponding to cell centers along the flow path. The same spatial reference as the input is used and the paths are attributed with the feature IDs of the provided drainage points.</p>"},{"location":"user-guide/feature-extraction/flow-length/#visualization","title":"Visualization","text":"Input DEM Flow Length Output"},{"location":"user-guide/feature-extraction/flow-length/#drainage-point-snapping","title":"Drainage Point Snapping","text":"<p>Snapping corrects drainage point locations that fall slightly off stream channels due to digitization error or CRS mismatch.</p> <p>Snapping requires accumulation raster with values representing upstream cell count. Without snapping, drainage points used at exact provided coordinates\u2014may not correspond to stream channel locations.</p>"},{"location":"user-guide/feature-extraction/flow-length/#see-also","title":"See Also","text":"<ul> <li>Flow Direction - Computing flow directions for flow length analysis</li> <li>Basin Delineation - Delineating watersheds for flow length computation</li> <li>Stream Extraction - Generating drainage points at stream junctions</li> <li>Complete Pipeline - End-to-end workflow</li> <li>Flow Length Algorithm - Implementation details</li> </ul>"},{"location":"user-guide/feature-extraction/streams/","title":"Stream Extraction","text":""},{"location":"user-guide/feature-extraction/streams/#purpose","title":"Purpose","text":"<p>Stream extraction converts accumulation-defined stream cells into vector line features. Cells exceeding accumulation threshold are classified as streams, vectorized into polylines, and written with junction points to GeoPackage output.</p>"},{"location":"user-guide/feature-extraction/streams/#parameters","title":"Parameters","text":""},{"location":"user-guide/feature-extraction/streams/#fac_path","title":"fac_path","text":"<p>Path to flow accumulation raster. GDAL-readable format. Single band. Int64 data type. Values represent upstream cell count. Nodata values (-1) excluded from stream classification.</p>"},{"location":"user-guide/feature-extraction/streams/#fdr_path","title":"fdr_path","text":"<p>Path to flow direction raster. GDAL-readable format. Single band. UInt8 data type. Values 0-7 represent valid flow directions. Required for tracing stream connectivity and determining junction locations.</p>"},{"location":"user-guide/feature-extraction/streams/#output_dir","title":"output_dir","text":"<p>Directory for output files. Must exist, the function does not create the directory. Writes <code>streams.gpkg</code> containing two layers: <code>streams</code> (LineString geometries) and <code>junctions</code> (Point geometries). Overwrites existing file.</p>"},{"location":"user-guide/feature-extraction/streams/#threshold","title":"threshold","text":"<p>Minimum accumulation value for stream classification. Cells with \\(\\text{accumulation} \\geq \\text{threshold}\\) become stream cells. Controls stream network density. Lower values extract tributaries, higher values extract main channels only.</p>"},{"location":"user-guide/feature-extraction/streams/#chunk_size","title":"chunk_size","text":"<p>Tile dimension in pixels. Default 2048. Set to 0 or 1 for in-memory processing.</p>"},{"location":"user-guide/feature-extraction/streams/#progress_callback","title":"progress_callback","text":"<p>Optional callback for monitoring long operations. See ProgressCallback API.</p>"},{"location":"user-guide/feature-extraction/streams/#cli-usage","title":"CLI Usage","text":"<pre><code>overflow streams \\\n    --fac accum.tif \\\n    --fdr fdr.tif \\\n    --output streams_output \\\n    --threshold 100\n</code></pre>"},{"location":"user-guide/feature-extraction/streams/#python-api-usage","title":"Python API Usage","text":"<pre><code>import overflow\n\noverflow.streams(\n    fac_path=\"accum.tif\",\n    fdr_path=\"fdr.tif\",\n    output_dir=\"./output\",\n    threshold=100\n)\n</code></pre> <p>The output <code>streams.gpkg</code> will contain two layers:</p> <ul> <li>streams: The vectorized stream network of all cells with \\(\\text{accumulation} \\geq \\text{threshold}\\). The vertices of the polylines will be at the grid cell centers.</li> <li>junctions: Points at the downstream end of each reach and the upstream most points of the stream network.</li> </ul>"},{"location":"user-guide/feature-extraction/streams/#visualization","title":"Visualization","text":"Input Flow Accumulation Stream Classification Output <p>The input shows flow accumulation values with higher values (darker blue) indicating greater drainage area. The output shows binary stream classification where cells exceeding the threshold (8 in this example) are marked as streams (blue = 1) versus non-streams (gray = 0). The stream network follows the path of highest flow accumulation down the valley.</p> Input DEM Streams Output"},{"location":"user-guide/feature-extraction/streams/#see-also","title":"See Also","text":"<ul> <li>Flow Accumulation - Computing accumulation for stream extraction</li> <li>Basin Delineation - Delineating watersheds using stream junctions</li> <li>Complete Pipeline - End-to-end workflow</li> <li>Stream Extraction Algorithm - Implementation details</li> </ul>"},{"location":"user-guide/flow-routing/flow-accumulation/","title":"Flow Accumulation","text":""},{"location":"user-guide/flow-routing/flow-accumulation/#purpose","title":"Purpose","text":"<p>Flow accumulation computes upstream drainage area for each cell. Output value represents count of cells whose flow paths traverse the cell. Provides basis for stream network extraction.</p>"},{"location":"user-guide/flow-routing/flow-accumulation/#parameters","title":"Parameters","text":""},{"location":"user-guide/flow-routing/flow-accumulation/#input_path","title":"input_path","text":"<p>Path to flow direction raster. GDAL-readable format. Single band. UInt8 data type. Values 0-7 represent valid flow directions. Value 8 (undefined) not permitted (input must have all cells resolved). Value 9 (nodata) propagates to output.</p>"},{"location":"user-guide/flow-routing/flow-accumulation/#output_path","title":"output_path","text":"<p>Path for accumulation output. Written as GeoTIFF. Int64 data type. Inherits projection and geotransform from input. Nodata value set to -1. Values represent upstream cell count including the cell itself (minimum value 1 for cells with no upstream contributors).</p>"},{"location":"user-guide/flow-routing/flow-accumulation/#chunk_size","title":"chunk_size","text":"<p>Tile dimension in pixels. Default 2048. Set to 0 or 1 for in-memory processing.</p>"},{"location":"user-guide/flow-routing/flow-accumulation/#progress_callback","title":"progress_callback","text":"<p>Optional callback for monitoring long operations. See ProgressCallback API.</p>"},{"location":"user-guide/flow-routing/flow-accumulation/#cli-usage","title":"CLI Usage","text":"<pre><code>overflow accumulation \\\n    --input fdr.tif \\\n    --output accum.tif\n</code></pre>"},{"location":"user-guide/flow-routing/flow-accumulation/#python-api-usage","title":"Python API Usage","text":"<pre><code>import overflow\n\noverflow.accumulation(\n    input_path=\"fdr.tif\",\n    output_path=\"accum.tif\"\n)\n</code></pre> <p>The output raster values represent the total upstream cell count including self. The minimum value is 1 and values monotonically increase following flow paths downstream. Nodata cells have value -1 and are propagated down from the input.</p> <p>Note</p> <p>The flow direction raster MUST have all non-nodata cells contain valid defined flow directions (0-7) and must not contain cycles. These requirements are met automatically when using <code>flow_direction()</code> with <code>resolve_flats=True</code> on properly conditioned DEM.</p>"},{"location":"user-guide/flow-routing/flow-accumulation/#visualization","title":"Visualization","text":"Input Flow Direction Flow Accumulation Output <p>The input shows flow direction arrows overlaid on terrain with a valley down the center. Arrows converge toward the valley (\u2193) from both sides (\u2198 and \u2199). The flow accumulation output shows how many upstream cells drain through each location. Higher values (darker blue) indicate greater drainage area, with the valley channel collecting flow from both sides. The pattern clearly identifies potential stream locations where accumulation values are highest.</p>"},{"location":"user-guide/flow-routing/flow-accumulation/#see-also","title":"See Also","text":"<ul> <li>Flow Direction - Computing flow directions before accumulation</li> <li>Stream Extraction - Using accumulation to extract streams</li> <li>Basin Delineation - Delineating watersheds from flow network</li> <li>Complete Pipeline - End-to-end workflow</li> <li>Flow Accumulation Algorithm - Implementation details</li> </ul>"},{"location":"user-guide/flow-routing/flow-direction/","title":"Flow Direction and Flat Resolution","text":""},{"location":"user-guide/flow-routing/flow-direction/#purpose","title":"Purpose","text":"<p>Flow direction assigns each cell a D8 direction code indicating steepest descent to one of eight neighbors. Flat resolution eliminates undefined flow in flat regions by computing gradients away from higher terrain and toward lower terrain.</p>"},{"location":"user-guide/flow-routing/flow-direction/#flow-direction-encoding","title":"Flow Direction Encoding","text":"<p>Output raster uses byte encoding:</p> Value Direction Offset (col, row) 0 East (1, 0) 1 Northeast (1, -1) 2 North (0, -1) 3 Northwest (-1, -1) 4 West (-1, 0) 5 Southwest (-1, 1) 6 South (0, 1) 7 Southeast (1, 1) 8 Undefined - 9 Nodata - <p>See FlowDirection.</p> <p>Direction indices proceed counter-clockwise from East. Undefined cells occur in flat regions when flat resolution is disabled. Nodata cells inherit nodata status from input DEM.</p>"},{"location":"user-guide/flow-routing/flow-direction/#parameters","title":"Parameters","text":""},{"location":"user-guide/flow-routing/flow-direction/#input_path","title":"input_path","text":"<p>Path to conditioned DEM raster. GDAL-readable format. Single band. Float32. Must be hydrologically conditioned (filled) to prevent internal drainage.</p>"},{"location":"user-guide/flow-routing/flow-direction/#output_path","title":"output_path","text":"<p>Path for flow direction output. Written as GeoTIFF. UInt8 data type. Inherits projection and geotransform from input. Nodata value set to 9.</p>"},{"location":"user-guide/flow-routing/flow-direction/#chunk_size","title":"chunk_size","text":"<p>Tile dimension in pixels. Default 2048. Set to 0 or 1 for in-memory processing.</p>"},{"location":"user-guide/flow-routing/flow-direction/#working_dir","title":"working_dir","text":"<p>Directory for temporary files during flat resolution in tiled mode. Ignored for in-memory mode. When None, uses system temporary directory.</p>"},{"location":"user-guide/flow-routing/flow-direction/#resolve_flats","title":"resolve_flats","text":"<p>Boolean controlling flat resolution. Default True. When False, cells in flat regions assigned value 8 (undefined). When True, flat cells receive directions routing flow away from higher terrain and toward lower terrain. There will be no undefined cells.</p>"},{"location":"user-guide/flow-routing/flow-direction/#progress_callback","title":"progress_callback","text":"<p>Optional callback for monitoring long operations. See ProgressCallback API.</p>"},{"location":"user-guide/flow-routing/flow-direction/#flat_resolution_chunk_size_max","title":"flat_resolution_chunk_size_max","text":"<p>Maximum chunk size for flat resolution processing. Default 512. This parameter is only available in the Python API (not in the CLI) and provides advanced control over flat resolution performance.</p> <p>When <code>chunk_size</code> exceeds this value, flat resolution will automatically use this smaller chunk size instead. This prevents performance issues in areas with large contiguous regions of undefined flow (such as large filled depressions or water bodies), where large chunks can significantly slow down processing.</p> <p>Advanced Python API Only</p> <p>This parameter is intentionally not exposed in the CLI interface. It's an advanced feature that requires understanding of the performance implications of chunk size during flat resolution.</p>"},{"location":"user-guide/flow-routing/flow-direction/#cli-usage","title":"CLI Usage","text":"<pre><code>overflow flow-direction \\\n    --input dem_filled.tif \\\n    --output fdr.tif \\\n    --resolve-flats\n</code></pre>"},{"location":"user-guide/flow-routing/flow-direction/#python-api-usage","title":"Python API Usage","text":"<p>Basic usage:</p> <pre><code>import overflow\n\noverflow.flow_direction(\n    input_path=\"dem_filled.tif\",\n    output_path=\"fdr.tif\",\n    resolve_flats=True\n)\n</code></pre> <p>Advanced usage with custom flat resolution chunk size (Python API only):</p> <pre><code>import overflow\n\n# For large DEMs with significant flat areas, you may want to use\n# a larger chunk_size for flow direction computation but limit the\n# chunk size during flat resolution to avoid performance degradation\noverflow.flow_direction(\n    input_path=\"dem_filled.tif\",\n    output_path=\"fdr.tif\",\n    chunk_size=2048,  # Large chunks for flow direction\n    resolve_flats=True,\n    flat_resolution_chunk_size_max=512  # Cap flat resolution chunks\n)\n</code></pre> <p>In the output flow direction raster, every non-nodata cell with at least one lower neighbor has a defined flow direction (0-7). There will be no cycles in the flow direction raster. If <code>resolve_flats</code> is true, there will also be no undefined flow directions.</p> <p>Note</p> <p>In order to guarantee the flow direction raster is free of undefined flow directions, you MUST provide a DEM with no sinks/pits (i.e., the <code>fill</code> process has been run) AND set <code>resolve_flats</code> to <code>True</code>.</p>"},{"location":"user-guide/flow-routing/flow-direction/#visualization","title":"Visualization","text":"Input DEM Flow Direction Output <p>The input DEM shows elevation values sloping from upper-left (108) to lower-right (90). The flow direction output displays arrows indicating the D8 direction of steepest descent for each cell.</p> Input DEM Flow Direction Output"},{"location":"user-guide/flow-routing/flow-direction/#performance-considerations","title":"Performance Considerations","text":"<p>The tiled algorithm for flat resolution is the most computationally intensive process implemented in Overflow. Flow direction rasters with large contiguous areas of undefined flows (e.g., large filled depressions or water bodies) can have a significant performance hit if used with a large <code>chunk_size</code>.</p> <p>By default, the <code>flat_resolution_chunk_size_max</code> parameter caps the chunk size used during flat resolution at 512 pixels, even if you specify a larger <code>chunk_size</code> for the initial flow direction computation. This provides a good balance between performance and memory usage for most use cases.</p>"},{"location":"user-guide/flow-routing/flow-direction/#see-also","title":"See Also","text":"<ul> <li>Flow Accumulation - Computing drainage area from flow directions</li> <li>Fill Operation - Conditioning DEM before flow direction</li> <li>Complete Pipeline - End-to-end workflow</li> <li>Flow Direction Algorithm - Implementation details</li> <li>Flat Resolution Algorithm - Implementation details</li> </ul>"},{"location":"user-guide/terrain-conditioning/breach/","title":"Breach","text":""},{"location":"user-guide/terrain-conditioning/breach/#purpose","title":"Purpose","text":"<p>Breach removes depressions from a DEM by carving flow paths through elevation barriers. The operation identifies local minima and creates least-cost paths to adjacent lower terrain or domain boundaries.</p>"},{"location":"user-guide/terrain-conditioning/breach/#when-to-use","title":"When to Use","text":"<p>Breaching preserves natural terrain features by lowering barrier cells rather than raising depression interiors. Use breach when:</p> <ul> <li>Depressions result from data artifacts (bridges, culverts, missing data interpolation)</li> <li>Maintaining original elevation values in depression interiors is important</li> <li>Terrain contains linear barriers (roads, levees, embankments) obstructing flow</li> </ul> <p>Use fill instead when depressions represent genuine closed basins or when breach paths would require unrealistic terrain modification.</p> <p>Note</p> <p>Both breach and fill can be used together and it is generally recommended to do so.</p> <p>Note</p> <p>Breaching does not resolve undefined flow in flat areas. Apply <code>flow_direction()</code> with <code>resolve_flats=True</code> after breaching and filling.</p>"},{"location":"user-guide/terrain-conditioning/breach/#parameters","title":"Parameters","text":""},{"location":"user-guide/terrain-conditioning/breach/#input_path","title":"input_path","text":"<p>Path to input DEM raster. Must be GDAL-readable format. Single band. Float32 data type. Nodata cells propagate through output.</p>"},{"location":"user-guide/terrain-conditioning/breach/#output_path","title":"output_path","text":"<p>Path for output breached DEM. Written as GeoTIFF. Inherits projection, geotransform, and nodata value from input.</p>"},{"location":"user-guide/terrain-conditioning/breach/#chunk_size","title":"chunk_size","text":"<p>Tile dimension in pixels for processing. Default 2048. Set to 0 for in-memory processing when DEM fits in available RAM.</p>"},{"location":"user-guide/terrain-conditioning/breach/#search_radius","title":"search_radius","text":"<p>Maximum distance in cells to search for breach targets. Larger values increase computation time but allow breaching larger obstructions.</p>"},{"location":"user-guide/terrain-conditioning/breach/#max_cost","title":"max_cost","text":"<p>Maximum elevation sum removed along breach path. Default infinity (no constraint). When finite, prevents breaching depressions requiring excessive terrain modification. Cost computed as sum of elevation decrease at each modified cell.</p>"},{"location":"user-guide/terrain-conditioning/breach/#progress_callback","title":"progress_callback","text":"<p>Optional callback for monitoring long operations. See ProgressCallback API.</p>"},{"location":"user-guide/terrain-conditioning/breach/#cli-usage","title":"CLI Usage","text":"<pre><code>overflow breach \\\n    --input_file dem.tif \\\n    --output_file dem_breached.tif \\\n    --search_radius 50 \\\n    --max_cost 10.0\n</code></pre>"},{"location":"user-guide/terrain-conditioning/breach/#python-api-usage","title":"Python API Usage","text":"<pre><code>import overflow\n\noverflow.breach(\n    input_path=\"dem.tif\",\n    output_path=\"dem_breached.tif\",\n    search_radius=50,\n    max_cost=10.0\n)\n</code></pre> <p>The output DEM will have all depressions within <code>search_radius</code> cells of lower terrain breached. Unmodified cells retain their original elevations and no cells are raised. Nodata cells remain unchanged and are considered to be lower than any other cell.</p>"},{"location":"user-guide/terrain-conditioning/breach/#visualization","title":"Visualization","text":"Before Breach After Breach"},{"location":"user-guide/terrain-conditioning/breach/#performance-considerations","title":"Performance Considerations","text":"<p>Large search radii substantially increase processing time. Profile with typical data to determine acceptable trade-off between breach capability and runtime.</p> <p>Breaching May Leave Residual Pits</p> <p>The breach algorithm may leave some pits unresolved, either because they are beyond the search radius or due to tile boundary effects where pits near tile edges may be incompletely breached. You must run the <code>fill</code> process after breaching to ensure that no pits remain and produce a fully hydrologically conditioned DEM.</p> <p>Within each tile, pits are processed sequentially in a deterministic order, and later breaches can benefit from earlier breach paths through the use of the min() operation. However, tiles are processed in parallel, and pits located at tile boundaries may be processed differently by adjacent tiles, leading to potential artifacts at tile edges. These artifacts are resolved by the subsequent fill operation.</p>"},{"location":"user-guide/terrain-conditioning/breach/#see-also","title":"See Also","text":"<ul> <li>Fill - Depression removal method using priority flood fill algorithm</li> <li>Flow Direction - Computing flow routing after conditioning</li> <li>Pipeline - End-to-end workflow including breach</li> <li>Breach Algorithm Details - Implementation and theory</li> </ul>"},{"location":"user-guide/terrain-conditioning/fill/","title":"Fill","text":""},{"location":"user-guide/terrain-conditioning/fill/#purpose","title":"Purpose","text":"<p>Fill eliminates depressions by raising cell elevations to the lowest pour point elevation. The operation ensures water can flow from any cell to a domain boundary without encountering lower adjacent cells.</p>"},{"location":"user-guide/terrain-conditioning/fill/#when-to-use","title":"When to Use","text":"<p>Filling raises depression interiors rather than modifying barrier cells. Use fill when:</p> <ul> <li>Depressions represent genuine closed basins</li> <li>Preserving barrier elevations is more important than depression interiors</li> <li>Breaching would require extensive or unrealistic terrain modification</li> <li>Processing pipeline requires fully conditioned surface with no depressions</li> </ul> <p>Filling is typically applied after breaching to handle remaining depressions that breach cannot eliminate within search radius or cost constraints.</p> <p>Note</p> <p>Filling does not resolve undefined flow in flat areas and will in fact create flat areas of undefined flow anywhere that it fills. Apply <code>flow_direction()</code> with <code>resolve_flats=True</code> after breaching and filling.</p>"},{"location":"user-guide/terrain-conditioning/fill/#parameters","title":"Parameters","text":""},{"location":"user-guide/terrain-conditioning/fill/#input_path","title":"input_path","text":"<p>Path to input DEM raster. GDAL-readable format. Single band. Float32 data type. Nodata cells handled according to <code>fill_holes</code> parameter.</p>"},{"location":"user-guide/terrain-conditioning/fill/#output_path","title":"output_path","text":"<p>Path for output filled DEM. Written as GeoTIFF. Inherits projection and geotransform from input. When None, modifies input file in place.</p>"},{"location":"user-guide/terrain-conditioning/fill/#chunk_size","title":"chunk_size","text":"<p>Tile dimension in pixels for tiled processing. Default 2048. Set to 0 or 1 for in-memory processing.</p>"},{"location":"user-guide/terrain-conditioning/fill/#working_dir","title":"working_dir","text":"<p>Directory for temporary files during tiled processing. Ignored for in-memory mode. When None, uses system temporary directory.</p>"},{"location":"user-guide/terrain-conditioning/fill/#fill_holes","title":"fill_holes","text":"<p>Boolean flag controlling nodata region treatment. When False (default), nodata regions remain unchanged. When True, nodata cells assigned elevation of lowest surrounding valid cell, effectively filling nodata holes.</p>"},{"location":"user-guide/terrain-conditioning/fill/#progress_callback","title":"progress_callback","text":"<p>Optional callback for monitoring long operations. See ProgressCallback API.</p>"},{"location":"user-guide/terrain-conditioning/fill/#cli-usage","title":"CLI Usage","text":"<pre><code>overflow fill \\\n    --input_file dem.tif \\\n    --output_file dem_filled.tif\n</code></pre>"},{"location":"user-guide/terrain-conditioning/fill/#python-api-usage","title":"Python API Usage","text":"<pre><code>import overflow\n\n# Output to new file\noverflow.fill(\n    input_path=\"dem.tif\",\n    output_path=\"dem_filled.tif\"\n)\n\n# Modify in place\noverflow.fill(\n    input_path=\"dem.tif\",\n    output_path=None\n)\n</code></pre> <p>All cells in the output DEM will have a flow path to the domain boundary with monotonically decreasing or constant elevation. Unmodified cells retain their original elevations and no cells are lowered.</p>"},{"location":"user-guide/terrain-conditioning/fill/#visualization","title":"Visualization","text":"Before Fill After Fill"},{"location":"user-guide/terrain-conditioning/fill/#see-also","title":"See Also","text":"<ul> <li>Breach Operation - Alternative depression removal method</li> <li>Flow Direction - Computing flow after conditioning</li> <li>Complete Pipeline - End-to-end workflow including fill</li> <li>Fill Algorithm Details - Implementation and theory</li> </ul>"}]}